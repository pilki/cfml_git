Definition rep_from_eq : forall A, Rep A A.
Proof. intros. apply (Build_Rep eq). congruence. Defined.


Axiom lt_to_le : forall x y : T,
  x < y -> x <= y.
Hint Immediate lt_to_le.
(* todo: refaire sans ça 

Definition rep_spec_2 (a1 a2 A1 A2 B : Type)
  (rep1:a1->A1->Prop) (rep2:a2->A2->Prop)
  (RK:a1->a2->A1->A2->~~B->Prop) f :=
  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> RK x1 x2 X1 X2 R) f.

Definition rep_spec_2_hyp (a1 a2 A1 A2 B : Type)
  (rep1:a1->A1->Prop) (rep2:a2->A2->Prop) (P:A1->A2->Prop)
  (RK:a1->a2->A1->A2->~~B->Prop) f :=
  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> P X1 X2 -> RK x1 x2 X1 X2 R) f.

Axiom rep_induction_mut_2_2_2 : 
  forall (a11 a12 A11 A12 B1 : Type)
  (rep11:a11->A11->Prop) (rep12:a12->A12->Prop)
  (mu1:A11->A12->nat) (RK1:a11->a12->A11->A12->~~B1->Prop) f1,
  forall (a21 a22 A21 A22 B2 : Type)
  (rep21:a21->A21->Prop) (rep22:a22->A22->Prop)
  (mu2:A21->A22->nat) (RK2:a21->a22->A21->A22->~~B2->Prop) f2,
  let IH := (fun n => 
      rep_spec_2_hyp (B:=B1) rep11 rep12 (fun X11 X12 => (mu1 X11 X12 < n)%nat) RK1 f1
   /\ rep_spec_2_hyp (B:=B2) rep21 rep22 (fun X21 X22 => (mu2 X21 X22 < n)%nat) RK2 f2) in
  rep_spec_2_hyp (B:=B1) rep11 rep12 (fun X11 X12 => IH (mu1 X11 X12)) RK1 f1 -> 
  rep_spec_2_hyp (B:=B2) rep21 rep22 (fun X21 X22 => IH (mu2 X21 X22)) RK2 f2 -> 
     rep_spec_2 (B:=B1) rep11 rep12 RK1 f1 
  /\ rep_spec_2 (B:=B2) rep21 rep22 RK2 f2.

intros. sets_eq n: (length Q).
gen a A H x1 Q. apply~ good_induct; clears n.
introv IH. intros ? ? ? q Q RQ NE N. subst n.

*)


Definition min_of (E:multiset T) (X:T) := 
  X \in E /\ forall_ Y \in E, X <= Y.

Definition removed_min (E E':multiset T) :=
  exists X, min_of E X /\ E = \{X} \u E'.

  (* todo : inversion for fset 

Lemma in_node_cases : forall (X Y : T) (A B : LibSet.set T),
  X \in \{Y} \u A \u B -> 
  X = Y \/ X \in A \/ X \in B.
Proof.
  introv H. destruct (in_union_inv H) as [H'|H'].
    left. rewrite~ (in_single H').
    right. destruct (in_union_inv H'); eauto.
Qed.
*)

Lemma in_node_cases : forall (X Y : T) (A B : LibSet.set T),
  X \in \{Y} \u A \u B -> 
  X = Y \/ X \in A \/ X \in B.
Proof.
  introv H. destruct (in_union_inv H) as [H'|H'].
    left. rewrite~ (in_single H').
    right. destruct (in_union_inv H'); eauto.
Qed.


Class Model (A:Type) := 
  { model : Type }.

Implicit Arguments model [[Model]].

Notation "# A" := (model A) (at level 30).

Class Rep `{Model A} := 
  { rep : A -> model A -> Prop;
    rep_unique : forall x X Y, rep x X -> rep x Y -> X = Y }.

Implicit Arguments Rep [[H]].
Implicit Arguments Build_Rep [A [H]].

Instance nat_model : Model nat := nat.
Hint Unfold nat_model.

Definition k := #nat.
Eval hnf in k.
Parameter y : #nat.
Check (y : nat).
(*pas général
Lemma convert : nat -> model nat.
Proof. exact (@id _). Qed.
Coercion convert : nat >-> model.
*)
Parameter x : nat.
(* fails: Check (x : #nat). *)

Lemma test : forall (x : nat) (X : nat), rep x X.

Instance nat_rep : Rep nat.
Proof. apply (Build_Rep (@eq _)). congruence. Defined.



------------



Record repr (A:Type) :=
  { model :> Type;
    rep : A -> model -> Prop;
    rep_unique : forall x X Y, rep x X -> rep x Y -> X = Y }.

Lemma nat_repr : @repr nat.
Proof. apply (Build_repr (@eq _)). congruence. Defined.

Canonical Structure nat_repr.

Class Rep A := 
  { repr_of : repr A }.

Instance nat_rep : Rep nat := nat_repr.

Notation "# A" := (@repr_of A _) (at level 30).

Parameter y : #nat.
Check (y: nat).

Parameter x :nat.
Check (x: #nat).


Notation "# A" := (@model A _) (at level 30).



Lemma test : int = #int :> Type. reflexivity. Qed.
Parameter y :#int.
Check (y: int).

Parameter x :int.
Check (x: #int).


Program Lemma test' : forall (x:int) (X :#int), x = (X:int) :> int.





(* todo: where to define these in order to avoid copy-paste ? 
tester: min_of A `{Le A} (E:multiset A) (X:A).
dans LibMultiset.

Definition min_of (E:multiset T) (X:T) := 
  X \in E /\ forall_ Y \in E, X <= Y.

Definition removed_min (E E':multiset T) :=
  exists X, min_of E X /\ E = \{X} \u E'.

Hint Unfold removed_min.
*)


Ltac name_around e x :=
  pattern e; match goal with |- ?P _ => sets x: P end.

Definition spec_hyp_2 (A1 A2 B : Type)
  (P:A1->A2->Prop) (K:A1->A2->~~B->Prop) f :=
  spec_2 (fun x1 x2 R => P x1 x2 -> K x1 x2 R) f.

(*
Lemma spec_hyp_size : forall (A1 A2 : Type) (mu:A1->A2->nat) (B : Type)
  (P:A1->A2->Prop) (K:A1->A2->~~B->Prop) f,
  is_spec
  (forall n, spec_hyp_2 (fun x1 x2 => n = mu x1 x2) K f) ->
  spec_2 K f.
*)


(*
Inductive intbar :=
  | intbar_int : int -> intbar
  | intbar_inf : intbar.

Instance intbar_le : Le intbar := fun (x y : intbar) => 
  match x,y with
  | intbar_int n, intbar_int m => n <= m
  | intbar_inf, intbar_int n => False
  | _, intbar_inf => True
  end.

(* todo: generic min *)

Ltac simpl_intbar_le :=
  repeat match goal with H: (@le intbar _ _ _) |- _ =>
    simpl in H end.
   
Axiom min : int -> int -> int.

Definition min_intbar (x y : intbar) :=
  match x,y with
  | intbar_int n, intbar_int m => intbar_int (min n m)
  | intbar_int n, _ => intbar_int n
  | _, intbar_int n => intbar_int n
  | _,_ => intbar_inf
  end.

Axiom min_trans_elim : forall a b x y : int,
  min a b <= x -> y <= a -> y <= b -> y <= x.
  *)



(*

Coercion intbar_int : Z >-> intbar.
Notation "'oo'" := intbar_inf.

Definition Rank_hd (ts:heap) :=
  match ts with
  | nil => oo
  | t::ts => Rank t
  end.
*)


Definition rep_spec_2_hyp (a1 a2 A1 A2 B : Type)
  (rep1:a1->A1->Prop) (rep2:a2->A2->Prop) (P:A1->A2->Prop)
  (RK:a1->a2->A1->A2->~~B->Prop) f :=
  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> P X1 X2 -> RK x1 x2 X1 X2 R) f.

Lemma conj_strengthen_2 : forall (Q1 Q2 P1 P2 : Prop),
  (Q1 -> P1) -> (Q2 -> P2) -> (Q1 /\ Q2) -> (P1 /\ P2).
Proof. auto*. Qed.

Lemma rep_spec_2_size : forall A1 A2 (mu:A1->A2->nat) 
  (a1 a2 B : Type) (rep1:a1->A1->Prop) (rep2:a2->A2->Prop) 
  (RK:a1->a2->A1->A2->~~B->Prop) f,
  (forall n, rep_spec_2_hyp rep1 rep2 (fun X1 X2 => mu X1 X2 = n) RK f) ->
  rep_spec_2 rep1 rep2 RK f.
Proof.
  introv H.
  unfolds. xintros.  unfolds. split. xweaken. unfolds rep_spec_2_hyp. eapply H. xintros.
Qed.

  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> P X1 X2 -> RK x1 x2 X1 X2 R) f.

Lemma merge_spec : RepTotal merge (E1;heap) (E2;heap) >>
  E1 \u E2 ; heap.
Proof.
  applys (>>> proj1 __ link_spec).
  eapply conj_strengthen_2; try intros M.
  

  eapply rep_induction_mut_2_2_2 with 
   (mu1 := fun E1 E2 => (2 * (card E1 + card E2) + 1)%nat)
   (mu2 := fun E1 E2 => (2 * (card E1 + card E2))%nat);
   unfold rep_spec_2, rep_spec_2_hyp.
  (* verif merge *)
  xcf. introv R1 R2 [_ IH]. xmatch; xcleanpat.
  xgo. inverts R2. equates* 1.
  xgo. inverts R1. equates* 1.
  inverts R1. inverts R2. xapp~. xif.
    xapp~.
    applys_to P_x0 nle_to_sle. xapp~. ximpl. equates* 1.
  (* verif link *)
  xcf. intros h1 h2 E1 E2 R1 R2 [IH _] X MX GX. inverts R1. 
  xgo. applys_to MX proj1. eapply (in_empty X). eauto.
  xmatch.
  xgo. inverts H0. forwards~: (>>> min_of_eq MX). constructors*.
  xgo~. forwards~: (>>> min_of_eq MX). constructors*.
Qed.




(*
Lemma testing: 
  forall a A B (P:a->A->Prop) (K:a->A->~~B->Prop) (f:val),
  True ->
  spec_1 (fun x R => forall X, P x X -> K x X R) f.
Admitted.
*)
(*
Lemma min_of_eq : forall X Y E1 E2,
  min_of (\{Y} \u E1 \u E2) X ->
  foreach (is_ge X) E1 ->
  foreach (is_ge X) E2 ->
  X <= Y.
Proof.
  introv [M1 M2] G1 G2. multiset_in M1.
  apply le_refl.
  apply~ M2.
  apply~ M2.
Qed.
*)


(*
Lemma test : (BagEmpty (multiset T)).
typeclass. Qed.
Lemma test2 : (BagCard (multiset T)).
typeclass. Qed.
Lemma test23 : @card_empty (multiset T) _ _ _ = card_empty.
typeclass. Qed.
*)

(*
Definition sum_measure A1 A2 (mu1:A1->nat) (mu2:A2->nat) (p:A1+A2) : nat :=
  match p with 
  | inl x => mu1 x 
  | inr x => mu2 x 
  end.
  (*(sum_measure (fun h1 h2 => 2 * (size h1 + size h2)) (fun h size).*)

Definition size_pair (p:heap*heap) :=
  let (h1,h2) := p in (size h1 + size h2)%nat.
*)
(*
  sets lt: (fun p1 p2 => match p1,p2 with
    | inl x, inr y => size_pair x < size_pair y
    | inr x, inl y => size_pair x <= size_pair y
    | _,_ => False end).
*)

Lemma spec_induction_mut_2_2_2 : 
  forall A11 A12 B1 A21 A22 B2 (lt:binary(A11*A12+A21*A22)),
  forall (Wf: wf lt) f1 f2 (K1:A11->A12->~~B1->Prop) (K2:A21->A22->~~B2->Prop),
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => lt (inl (y1,y2)) (inl (x1,x2)) -> K1 y1 y2 R') f1 ->
    spec_2 (fun y1 y2 R' => lt (inr (y1,y2)) (inl (x1,x2)) -> K2 y1 y2 R') f2 ->
    K1 x1 x2 R) f1 ->
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => lt (inl (y1,y2)) (inr (x1,x2)) -> K1 y1 y2 R') f1 ->
    spec_2 (fun y1 y2 R' => lt (inr (y1,y2)) (inr (x1,x2)) -> K2 y1 y2 R') f2 ->
    K2 x1 x2 R) f2 ->
  spec_2 K1 f1 /\ spec_2 K2 f2.
Admitted.
*)

(*
Definition link_spec := Spec link h1 h2 |R>>
  forall E1 E2,
  inv h1 E1 ->
  inv h2 E2 ->
  forall x ho hs X Eo Es,
  h1 = Node x ho hs ->
  rep x X ->
  inv ho Eo ->
  inv hs Es ->
  foreach (is_ge X) Eo ->
  foreach (is_ge X) Es ->
  foreach (is_ge X) E2 ->
  R (\{X} \u Eo \u Es \u E2 ; heap).
*)
(*
Definition link_spec := RepSpec link (E1;heap) (E2;heap) |R>>
  forall x h1 ho hs X Eo Es,
  rep x X ->
  inv ho Eo ->
  inv hs Es ->
  h1 = Node x ho hs ->
  foreach (is_ge X) Eo ->
  foreach (is_ge X) Es ->
  foreach (is_ge X) E2 ->
  R (\{X} \u Eo \u Es \u E2 ; heap).
*)

(*
Definition is_rep_root X E :=
  match E with
  | Empty => False
  | Node x ho hs => rep x X 
  end.
*)

(* todo: simplify using rep_unique *)



(*-- old

Hint Extern 1 (RegisterSpec link) => Provide link_spec.

Lemma merge_spec : RepTotal merge (E1;heap) (E2;heap) >>
  E1 \u E2 ; heap.
Proof.
  xcf. introv R1 R2. xmatch; xcleanpat.
  xgo. inverts R2. equates* 1.
  xgo. inverts R1. equates* 1.
  inverts R1. inverts R2. xapp~. xif.
  xapp~. ximpl. equates* 1.
  applys_to P_x0 nle_to_sle. xapp~. ximpl. equates* 1.
Qed.

Hint Extern 1 (RegisterSpec merge) => Provide merge_spec.

Lemma link_spec : Spec link h1 h2 |R>>
  forall x ho hs X Eo Es E2,
  h1 = Node x ho hs ->
  rep x X ->
  inv ho Eo ->
  inv hs Es ->
  inv h2 E2 ->
  foreach (is_ge X) Eo ->
  foreach (is_ge X) Es ->
  foreach (is_ge X) E2 ->
  R (\{X} \u Eo \u Es \u E2 ; heap).
Proof.
  xcf. introv Sh1 Rx Ro Rs R2 Lo Ls L2.
  xmatch; inverts H.
  xgo. inverts Ro. constructors*.
  xgo~. constructors*.
Qed.

Hint Extern 1 (RegisterSpec link) => Provide link_spec.

*)


(*
Definition spec_measure_2 
  A1 A2 B (size:A1->A2->nat)
  f (K:A1->A2->~~B->Prop) :=
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => (size y1 y2 < size x1 x2)%nat -> K y1 y2 R') f ->
    K x1 x2 R) f.

Let measure_for2 : forall 
  A11 A12 B1 (size1:A11->A12->nat) f1 (K1:A11->A12->~~B1->Prop) 
  A21 A22 B2 (size2:A21->A22->nat) f2 (K2:A12->A22->~~B2->Prop),
  
(P Q : nat -> Prop),
  (forall n, (forall m, m < n -> P n))

  (forall n, P n /\ Q n).
*)

Lemma merge_spec : RepTotal merge (E1;heap) (E2;heap) >>
  E1 \u E2 ; heap.
Proof.
  xintros. intros h1 h2. intros. sets_eq n: ((size h1 + size h2)%nat).
  gen EQn. gen h1 h2 E1 E2. pattern n.
  match goal with |- ?P _ => sets m_spec: P end.
  applys (>>> proj1 __ (link_spec (S n))). move n after m_spec.
  induction n using peano_induction. rename H into IH. split. 
  (* verif merge *)
  unfolds. clears. introv R1 R2 N. xcf_app. xmatch; xcleanpat.
  xgo. inverts R2. equates* 1.
  xgo. inverts R1. equates* 1.
  inverts R1. inverts R2.
   simpl in N. forwards (_&K): (IH ((n-1)%nat)). math. unfolds in K.
   xapp~. xif.
     xapp~. ximpl. equates* 1.
     applys_to P_x0 nle_to_sle. xapp~. ximpl. equates* 1.
  (* verif link *)
  unfolds. xcf. introv Sh1 Rx Ro Rs R2 Lo Ls L2 N.
  forwards (K&_): (IH ((size h + size a)%nat)). skip. 
   unfolds in K. clears.
  xmatch; inverts H.
  xgo. inverts Ro. constructors*. simpl in K.
  xgo~. xapp. constructors*.
Qed.

(*


Axiom factorize : forall (P1 P2 P3 P4 P5 : nat -> Prop),
  (forall n, P1 n /\ P2 n /\ P3 n /\ P4 n /\ P5 n) ->
  (forall n, P1 (n)) /\ (forall n, P2 (n)) /\ (forall n, P3 (n))
    /\ (forall n, P4 (n))  /\ (forall n, P5 (n)).

Lemma eq_gt_induction_5' : forall (P1 P2 P3 P4 P5 : (nat->Prop) -> Prop),
  eq_gt_implies P1 -> eq_gt_implies P2 -> eq_gt_implies P3 -> 
  eq_gt_implies P4 -> eq_gt_implies P5 ->
  (forall n, P1 (gt n) -> P2 (gt n) -> P3 (gt n) -> P4 (gt n) -> P5 (gt n) -> 
    P1 (eq n) /\ P2 (eq n) /\ P3 (eq n) /\ P4 (eq n) /\ P5 (eq n)) ->
  (forall n, P1 (eq n) /\ P2 (eq n) /\ P3 (eq n) /\ P4 (eq n) /\ P5 (eq n)).
Proof. 
  introv H1 H2 H3 H4 H5 R.
  induction n using peano_induction. apply R;
    match goal with K: eq_gt_implies ?Pi |- ?Pi _ =>
      apply K; intros; forwards*: H; try math end.
Qed. 

Axiom go :forall (P1 P2 P3 P4 P5 : (nat->Prop) -> Prop),
 (forall n, P1 (eq n) /\ P2 (eq n) /\ P3 (eq n) /\ P4 (eq n) /\ P5 (eq n)).
(*
Lemma conj_strengthen_5' : forall (Q1 Q2 Q3 Q4 Q5 P1 P2 P3 P4 P5 : (nat -> Prop) -> Prop),
  (Q1 -> P1) -> (Q2 -> P2) -> (Q3 -> P3) -> (Q4 -> P4) -> (Q5 -> P5) ->
  (Q1 /\ Q2 /\ Q3 /\ Q4 /\ Q5) -> (P1 /\ P2 /\ P3 /\ P4 /\ P5).
Proof. auto*. Qed.
*)

(*
Axiom go' :forall (P1 : (nat->Prop) -> Prop),
 (forall n, P1 (eq n)).

Axiom go'' :forall f n  (P1 P2 : (nat->Prop) -> Prop),
 (f = eq n -> (P1 f /\ P2 f)).
*)
*)
(* todo: move *)




(*
  eapply rep_induction_mut_2_2_2 with 
   (mu1 := fun E1 E2 => (2 * (card E1 + card E2) + 1)%nat)
   (mu2 := fun E1 E2 => (2 * (card E1 + card E2))%nat);
   unfold rep_spec_2, rep_spec_2_hyp.
*)

(*
Hint Extern 1 (@gt nat _ _ _) => check_noevar tt; simpl; rew_card; math.
*)


(*
Ltac all_specs_go :=
  unfolds; first [ xintros; instantiate;  
    [ xcf; auto; 
      try match goal with H: Rep ?a _ |- _ => instantiate (1 := a) end;
      try xisspec | ]
  | xintros ].
*)





(* todo: remove this
Ltac xcurried_core ::=
  let arity := spec_goal_arity tt in
  let lemma := get_curried_prove_x arity in
  eapply lemma; try solve [ xcf; auto; instantiate; 
    try (check_noevar_goal; xisspec) ].
 *)



(* todo: move *)
Lemma Forall2_unique : forall A1 A2 (P:A1->A2->Prop) l L1 L2,
  (forall x X Y, P x X -> P x Y -> X = Y) -> 
  Forall2 P l L1 -> Forall2 P l L2 -> L1 = L2.
Proof.
  induction l; introv H H1 H2; inverts H1; inverts H2; prove_rep.
Qed.

Hint Resolve Forall2_unique : rep.





(* bin:
Lemma inv_nil_change : forall rs rs' Es, 
  inv rs nil Es -> 0 <= rs' -> inv rs' nil Es.
Proof. introv H P. inverts~ H. Qed.


Definition Rank_hd_or r (ts:heap) :=
  match ts with
  | nil => r
  | t::ts => Rank t
  end.

Lemma le_rank_hd_or_elim : forall r ts,
  r <= Rank_hd_or r ts ->
  r <= Rank_hd ts.
Proof. intros. destruct ts.

Lemma inv_smallest : forall rs ts Es,
  inv rs ts Es -> 
  exists rs',
  inv rs' ts Es /\
  rs' <= rs /\
  (ts = nil -> rs' = 0).
Proof.
  introv H. inverts H. exists~ 0.
  exists rs. splits. auto~. auto~. auto_false.
Qed. (* todo: improve autofalse *)


Lemma remove_min_tree_spec : Spec remove_min_tree (ts:heap) |R>>
  forall rs Es, inv rs ts Es -> Es <> \{} -> 
  R (fun o => let (t',ts') := o : tree * heap in
     exists E' Es' X r' rs', 
       btree r' t' E' /\
       inv rs' ts' Es' /\
       Es = E' \u Es' /\
       rep (Root t') X /\
       foreach (is_ge X) Es /\ 
       rs <= rs').
Proof.
(*
  xinduction (@List.length tree). xcf. introv IH RH NE. xmatch.
  xgo. inverts RH. false.
  xgo. inverts RH as Rt R0. inverts R0. 
    lets (X&RX&MX): (root_le_all Rt). subst Es. exists~ ___.
  lets (rs0&E0&Ez&Rt&Rts&K1&K2&EQ): (inv_cons_inv RH). clear RH.
  asserts: (Ez <> \{}). intro_subst_hyp.
    destruct ts. inverts Rts. false. inverts Rts as BT. lets: (btree_not_empty BT).
    skip. (*fsetinv*)
  xapp~. destruct _x1 as [t' ts'].
   destruct P_x1 as (E'&Es'&X&r'&rs'&Rt'&Rts'&EQ'&RX&MX&D).
  xmatch. xapp~. xapp~. cbv beta in *. subst _x3 _x4. 
  lets (Y&RY&MY): (root_le_all Rt). xgo~.
  subst Es. exists~ ___.
  subst Es Ez. applys_to P_x2 nle_to_sle. 
    exists E' (E0 \u Es') __ __ __. splits~. permut_simpl.
*) skip.
Qed.

Hint Extern 1 (RegisterSpec remove_min_tree) => Provide remove_min_tree_spec.

Lemma find_min_spec : RepSpec find_min (E;heap) |R>>
  E <> \{} -> R (min_of E ;; O.t).
Proof.
  xcf. intros e E RepE HasE. simpl in RepE. xgo~.
  destruct P_x0 as (E'&Es'&X&r'&rs'&Rt'&Rts'&EQ'&RX&MX&D).
  ximpl as x Px. subst x. skip: (X \in E). eauto. 
  (* todo: rep_unique to solve this *)
Qed.

Hint Extern 1 (RegisterSpec find_min) => Provide find_min_spec.

Lemma delete_min_spec : RepSpec delete_min (E;heap) |R>>
  E <> \{} -> R (removed_min E ;; heap).
Proof. 
  xcf. introv Rts NE. simpl in Rts. xapp~. xmatch.
  destruct P_x0 as (E'&Es'&X&r'&rs'&Rt'&Rts'&EQ'&RX&MX&D).
  simpl in RX. clear H.
  asserts: (_p0 = r'). inverts~ Rt'. subst.
    forwards~ (Er&I'&EQ'): (>>> inv_rev_children_final x ts1).
  xapp~.  
    sapply~ inv_rank_smaller.
    ximpl as h Ph.
  exists (Er \u Es'). split~. subst E'. exists* X.
Qed.

Hint Extern

*)


(** termination relation *)
(* we could use a size function as well *)

Inductive subtree : set -> set -> Prop :=
  | subtree_left : forall col a x b, subtree a (Node col a x b)
  | subtree_right : forall col a x b, subtree b (Node col a x b).

Hint Constructors subtree.

Lemma subtree_wf : wf subtree.
Proof.
  intros e. induction e;
    constructor; introv H; inversions~ H.
Qed.

Hint Resolve subtree_wf : wf.


Inductive subtree : set -> set -> Prop :=
  | subtree_left : forall a x b, subtree a (Node a x b)
  | subtree_right : forall a x b, subtree b (Node a x b).

Hint Constructors subtree.

Lemma subtree_wf : wf subtree.
Proof.
  intros e. induction e;
    constructor; introv H; inversions~ H.
Qed.

Hint Resolve subtree_wf : wf.

  xinduction (unproj22 elem subtree).  


(* todo: move *)
Lemma Forall2_unique : forall A1 A2 (P:A1->A2->Prop) l L1 L2,
  (forall x X Y, P x X -> P x Y -> X = Y) -> 
  Forall2 P l L1 -> Forall2 P l L2 -> L1 = L2.
Proof.
  induction l; introv H H1 H2; inverts H1; inverts H2; prove_rep.
Qed.

Hint Resolve Forall2_unique : rep.

(*todo:move
Definition rep_from_eq : forall A, Rep A A.
Proof. intros. apply (Build_Rep eq). congruence. Defined.
*)