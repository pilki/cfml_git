
(*
Notation "'exists' ( x1 : T1 ) ',' P" :=
  (exists x1:T1, P)
  (at level 200, x1 ident, 
   right associativity) : type_scope. 
Notation "'exists' ( x1 : T1 ) ( x2 : T2 ) ',' P" :=
  (exists x1:T1, exists x2:T2, P)
  (at level 200, x1 ident, x2 ident, 
   right associativity) : type_scope.  
Notation "'exists' ( x1 : T1 ) ( x2 : T2 ) ( x3 : T3 ) ',' P" :=
  (exists x1:T1, exists x2:T2, exists x3:T3, P)
  (at level 200, x1 ident, x2 ident, x3 ident, 
   right associativity) : type_scope. 
Notation "'exists' ( x1 : T1 ) ( x2 : T2 ) ( x3 : T3 ) ( x4 : T4 ) ',' P" :=
  (exists x1:T1, exists x2:T2, exists x3:T3, exists x4:T4, P)
  (at level 200, x1 ident, x2 ident, x3 ident, x4 ident, 
   right associativity) : type_scope. 
*)


Record dynamic := dyn {_type : Type; 
  dyn_value : dyn_type }.

Inductive heap_c : Type :=
| empty_c : heap_c
| cons_c : nat -> dynamic -> heap_c -> heap_c.

Definition array A := nat -> A -> Prop.
Definition map A B := A -> B -> Prop.
Definition map' := map.
Definition heap := map nat dynamic.
Definition f (y:array nat) := dyn y.
Require Import List.
Print list.
(* map nat nat*)




Definition map A B := A -> B.
Definition heap := map nat dynamic.
Definition f (y:map nat nat) := 
  fun x:nat => dyn y.


(*
Proof.
  intro. extens. intros H Q. iff M.
  apply~ local_erase.
  introv Hh. destruct (M _ Hh) as (H1&H2&Q1&H'&R&N&?).
  lets (h1&h2&?&?&?&?): R. clear R.
  destruct~ (N h1) as (H1'&H2'&Q1'&?&?&?).
  exists H1' (H2 \* H2') Q1'.
  splits~. rewrite (star_comm H2). rewrite star_assoc. exists h1 h2. splits~.
  intros g. specializes H9 g.
  rewrite (star_comm H2). rewrite star_assoc.
  apply* local_wgframe.
Qed.
*)
(*
  introv Hh. destruct (M _ Hh) as (H1&H2&Q1&H'&R&N&?).
  destruct R as (h1&h2&?&?&?&?).
  destruct~ (N h1) as (Q'&?&?).
  exists (Q' \*+ H2). split.
  rewrite app_local_1. introv Hh'.
  apply* local_wframe.
*)

(*
  destruct M as (H1&H2&Q1&H'&?&(Qg&?&Hg)&?).
  exists (fun g => Qg g ** H2). splits.
    apply* local_frame.
    intros. specializes Hg g. apply* local_elim.
*)




(*  forall h, H h ->
  exists H1 H2 Q1, 
     (H1 \* H2) h 
  /\ app_1 f x1 H1 Q1 
  /\ forall g, app_1 g x2 (Q1 g \* H2) Q.
*)

(*
  forall h, H h ->
  exists Q', app_1 f x1 H Q' 
          /\ forall g, app_1 g x2 (Q' g) Q.
*)


(********************************************************************)
(* ** OLD Axioms *)

(** The type Func *)

Axiom val : Type. 

(** The type Func is inhabited *)

Axiom val_inhab : Inhab val. 
Existing Instance val_inhab.

(** The predicate AppReturns *)

Axiom app_1 : forall A B,  
  val -> A -> hprop -> (B -> hprop) -> Prop.

(** The predicate AppPure *)

Axiom pureapp : forall A B,  
  val -> A -> (B -> Prop) -> Prop.

(** AppReturns is a local property *)

Axiom app_local_1 : forall B A1 (x1:A1) f,
  is_local (app_1 (B:=B) f x1). 

(** AppPure satisfies the witness property *)

Axiom pureapp_concrete : forall A B (F:val) (V:A) (P:B->Prop),
  pureapp F V P <-> exists V', P V' /\ pureapp F V (= V').

(** AppPure satisfies the determinacy property *)

Axiom pureapp_deterministic : forall A B (F:val) (V:A) (V1' V2':B),
  pureapp F V (= V1') -> pureapp F V (= V2') -> V1' = V2'.          

(** From AppPure to AppReturns *)

Axiom pureapp_to_app : forall A B (F:val) (V:A) (P:B->Prop),
  pureapp F V P -> app_1 F V [] \[P].
  (* Could also be stated: [pureapp F V ==> pure (app_1 F V)] *)

(** Overlapping of AppPure and AppReturns *)

Axiom pureapp_and_app : forall A B (F:val) (V:A) (V':B) (H:hprop) (Q:B->hprop),
  pureapp F V (= V') -> app_1 F V H Q -> (H ==> Q V').



(********************************************************************)
(* ** Low-level axioms *)

(** The type of terms *)

Axiom trm : Type. 

(** The type Func *)

Axiom val : Type. 

(** The type Func is inhabited *)

Axiom val_inhab : Inhab val. 
Existing Instance val_inhab.

(** The construction of applications *)

Axiom app_trm : forall A, val -> A -> trm. (* todo: as relation *)

(** The evaluation predicate: [eval t h v h'] *)

Axiom eval : forall A, trm -> heap -> A -> heap -> Prop.

(** Evaluation is deterministic *)

Axiom eval_deterministic : forall A t h (v1 v2:A) h1 h2,
  eval t h v1 h1 -> eval t h v2 h2 -> v1 = v2 /\ h1 = h2.
  


Lemma hdata_unfold : forall (l l' : loc) (P:loc->hprop),
  hdata (fun l' => P l') l = hdata P l.
Proof. auto. Qed.



(*
Lemma hclean_end : forall B (F:~~B) H Q,
  is_local F -> F ([] \* H) Q -> F H Q.
Proof. intros. rew_heap in *. auto. Qed.
*)



Definition heap_is_single (l:loc) A (P:A->Prop) : hprop := 
  fun h => exists v, h = heap_single l v /\ P v.


(********************************************************************)
(* ** Locality *)

(*------------------------------------------------------------------*)
(* ** Definition of [local] *)

(** Type of post-conditions on values of type B *)

Notation "'~~' B" := (hprop->(B->hprop)->Prop) 
  (at level 8, only parsing) : type_scope.

(** "Local" = Frame rule + consequence rule + garbage collection *)

Definition local B (F:~~B) : ~~B :=
  fun (H:hprop) (Q:B->hprop) =>
    exists H1 H2 Q1 H',
       H ==> H1 * H2
    /\ F H1 Q1
    /\ forall x, (Q1 x) * H2 ==> (Q x) * H'.

(** Characterization of "local" judgments *)

Definition is_local B (F:~~B) :=
  F = local F.

(** The weakening property is implied by locality *)

Definition weakenable B (F:~~B) :=
  forall H Q , F H Q ->
  forall H' Q', H' ==> H -> Q ===> Q' -> F H' Q'.


(*------------------------------------------------------------------*)
(* ** Properties of [local] *)

(** The [local] operator can be freely erased from a conclusion *)

Lemma local_erase : forall B (F:~~B), 
  forall H Q, F H Q -> local F H Q.
Proof.
  intros. exists H [] Q []. splits.
  rew_heap~. auto. auto.
Qed.

(** Nested applications [local] are redundant *)

Lemma local_local : forall B (F:~~B),
  local (local F) = local F.
Proof.
  extens. intros H Q. iff M. 
  destruct M as (H1&H2&Q1&H'&?&N&?).
  destruct N as (H1'&H2'&Q1'&H''&?&?&?).
  exists H1' (H2 ** H2') Q1' (H' ** H''). splits.
  eapply pred_le_trans. eauto.
   intros h Hh. hnf in Hh. destruct Hh as (h1&h2&?&?&?&?).
   subst h. applys_to H9 H4. intuit H9. subst h1.
   rewrite (star_comm H2). rewrite star_assoc.
   exists __ __. splits~. exists __ __. splits~.
  eauto.
  intros.
  skip. (* todo *)
  apply~ local_erase.
Qed.

(** A definition whose head is [local] satisfies [is_local] *)

Lemma local_is_local : forall B (F:~~B),
  is_local (local F).
Proof. intros. unfolds. rewrite~ local_local. Qed.

(** Elimination lemma associated with the definition of [local] *)

Lemma local_elim : forall B (F:~~B) H H1 H2 H' Q1 Q,
  is_local F -> 
  F H1 Q1 -> 
  H ==> H1 ** H2 -> 
  Q1 *** H2 ===> Q *** H' ->
  F H Q.
Proof.
  introv L M WH WQ. rewrite L. exists H1 H2 Q1 H'. splits.
  auto. auto. intros. rew_heap~. apply WQ.
Qed.

(** Corrolary for the case where no garbage collection is required *)

Lemma local_frame : forall B (F:~~B) H H1 H2 Q1 Q,
  is_local F -> 
  F H1 Q1 -> 
  H ==> H1 ** H2 -> 
  Q1 *** H2 ===> Q ->
  F H Q.
Proof.
  intros. eapply local_elim with (H' := []); eauto. rew_heap~.
Qed.

(** Corrolary for the case where no frame is required *)

Lemma local_weaken : forall B (F:~~B) H H' Q Q',
  is_local F -> 
  F H' Q' -> 
  H ==> H' -> 
  Q' ===> Q ->
  F H Q.
Proof.
  intros. eapply local_frame with (H2 := []); eauto; rew_heap~.
Qed.

Lemma local_weaken' : forall B (F:~~B),
  is_local F -> weakenable F.
Proof. intros_all. apply* local_weaken. Qed.
  (* todo: use only one lemma *)


Definition local' B (F:~~B) : ~~B :=
  fun (H:hprop) (Q:B->hprop) =>
    exists H1 H2 P Q1 H',
       H ==> H1 * H2 * [P]
    /\ (P -> F H1 Q1)
    /\ forall x, (Q1 x) * H2 ==> (Q x) * H'.

Lemma local_intro_prop : forall B (F:~~B) H1 H2 (P:Prop) Q,
  is_local F -> (P -> F (H1 * H2) Q) -> F (H1 * [P] * H2) Q.
Proof.
  introv L M. rewrite L.
  skip_rewrite (local = local').
  exists (H1 * H2) [] P Q []. splits.
  skip. (* heaps *)
  auto.
  auto.
Qed. 

Lemma local_intro_exists : forall B (F:~~B) H1 H2 A (J:A->hprop) Q,
  is_local F -> (forall x, F (H1 * (J x) * H2) Q) ->
   F (H1 * heap_is_pack J * H2) Q.
Proof.
  introv L M. rewrite L.
  skip_rewrite (local = local').
  exists (H1 * H2) [] True Q []. splits.
  skip. (* heaps *)
  auto.
  auto.
Qed. 





(* don't do those, cause need to use spec_elim_3_2 directly
   to know partial apps have no effects
Lemma app_intro_3_2 :
  app_3 f x1 x2 x3 H Q ->
  (exists Q', app_2 f x1 x2 H Q' 
           /\ forall g, app_1 g x3 (Q' g) Q) ->

  app_2 f x1 x2 H (fun g h => app_1 g x3 (= h) Q).
Proof. skip. Qed.
*)

(*

Lemma app_intro_1_2 : 
  app_1 f x1 H (fun g h => app_1 g x2 (= h) Q) ->
  app_2 f x1 x2 H Q.
Proof.
  introv M. hnf. esplit. split. eauto.
  intros.
(*
  introv M. exists H [] __ []. splits.
    rew_heap~.
    apply M.
    intros x K S. rew_heap~ in *.
*)
Qed.

Lemma app_intro_2_1 : 
  app_2 f x1 x2 H Q ->
  app_1 f x1 H (fun g h => app_1 g x2 (= h) Q).
Proof.
  introv M. rewrite app_local_1.
  intuit M. exists___*.
Qed.

Lemma app_intro_2_3 : 
  app_2 f x1 x2 H (fun g h => app_1 g x3 (= h) Q) ->
  app_3 f x1 x2 x3 H Q.
Proof. skip. Qed.

Lemma app_intro_2_4 : 
  app_2 f x1 x2 H (fun g h => app_2 g x3 x4 (= h) Q) ->
  app_4 f x1 x2 x3 x4 H Q.
Proof. skip. Qed.

Lemma app_intro_3_1 : 
  app_3 f x1 x2 x3 H Q ->
  app_1 f x1 H (fun g h => app_2 g x2 x3 (= h) Q).
Proof. skip. Qed.

Lemma app_intro_3_2 :
  app_3 f x1 x2 x3 H Q ->
  app_2 f x1 x2 H (fun g h => app_1 g x3 (= h) Q).
Proof. skip. Qed.

Lemma app_intro_3_4 : 
  app_3 f x1 x2 x3 H (fun g h => app_1 g x4 (= h) Q) ->
  app_4 f x1 x2 x3 x4 H Q.
Proof. skip. Qed.

Lemma app_intro_4_1 :
  app_4 f x1 x2 x3 x4 H Q ->
  app_1 f x1 H (fun g h => app_3 g x2 x3 x4 (= h) Q).
Proof. skip. Qed.

Lemma app_intro_4_2 :
  app_4 f x1 x2 x3 x4 H Q ->
  app_2 f x1 x2 H (fun g h => app_2 g x3 x4 (= h) Q).
Proof. skip. Qed.

Lemma app_intro_4_3 :
  app_4 f x1 x2 x3 x4 H Q ->
  app_3 f x1 x2 x3 H (fun g h => app_1 g x4 (= h) Q).
Proof. skip. Qed.

*)


Lemma app_intro_2_3' : 
  (exists Q', app_2 f x1 x2 H Q' 
           /\ forall g, app_1 g x3 (Q' g) Q) ->
  app_3 f x1 x2 x3 H Q.
Proof. 
  introv (Q2&(Q1&M1&M2)&M3).
  exists Q1. split~. intros g. exists~ Q2.
Qed.


(********************************************************************)
(* ** Corrolaries from locality *)

(* AppReturns satisfies the weakening property *)

Lemma app_weaken_1 : forall B A1 (x1:A1) f,
  @weakenable B (app_1 f x1).
Proof. intros. apply~ local_weaken'. Qed.

(* todo: other needed?*)


Lemma curried_1_true : forall A1 B f, curried_1 A1 B f.
Proof. split. intros_all~. auto. Qed. 



(********************************************************************)
(* ** Weakenability of app *)

(* automatic from local_weaken

Lemma app_weakenable_1 : forall A1 B f x1,
  weakenable (@app_1 A1 B f x1).
Proof. intros_all. apply~ (app_weaken_1 H). Qed.

Lemma app_weakenable_2 : forall A1 A2 B f x1 x2,
  weakenable (@app_2 A1 A2 B f x1 x2).
Proof.
   intros_all. apply (app_weaken_1 H). 
   intros_all. applys* app_weakenable_1.
Qed.

Lemma app_weakenable_3 : forall A1 A2 A3 B f x1 x2 x3,
  weakenable (@app_3 A1 A2 A3 B f x1 x2 x3).
Proof.
   intros_all. apply (app_weaken_1 H). 
   intros_all. applys* app_weakenable_2.
Qed.

Lemma app_weakenable_4 : forall A1 A2 A3 A4 B f x1 x2 x3 x4,
  weakenable (@app_4 A1 A2 A3 A4 B f x1 x2 x3 x4).
Proof.
   intros_all. apply (app_weaken_1 H). 
   intros_all. applys* app_weakenable_3.
Qed.

Hint Resolve app_weakenable_1 app_weakenable_2 
  app_weakenable_3 app_weakenable_4.

*)



(*app_weaken_1;
  intros. introv M WH WQ. rewrite app_local_1.
  exists H [] Q []. splits. 
  rew_heap~.
  auto.
  intros. rew_heap~.
*)


(*
Definition app_2 A1 A2 B f (x1:A1) (x2:A2) (H:hprop) (Q:B->hprop) := 
  app_1 f x1 H (fun g h' => app_1 g x2 (= h') Q).

Definition app_3 A1 A2 A3 B f (x1:A1) (x2:A2) (x3:A3) (H:hprop) (Q:B->hprop) := 
  app_1 f x1 H (fun g h' => app_2 g x2 x3 (= h') Q).

Definition app_4 A1 A2 A3 A4 B f (x1:A1) (x2:A2) (x3:A3) (x4:A4) (H:hprop) (Q:B->hprop) := 
  app_1 f x1 H (fun g h' => app_3 g x2 x3 x4 (= h') Q).
*)


(* old
Lemma app_local_2 : forall B A1 A2 (x1:A1) (x2:A2) f,
  (app_2 f x1 x2) = @local B (app_2 f x1 x2).
Proof.
  intros. extens. intros H Q. iff M.
  apply~ local_erase.
  destruct M as (H1&H2&Q1&H'&?&?&?).
  unfolds app_2. 
  rewrite app_local_1.
  exists H1 (H2 ** H') __ []. splits.
  auto.
  eauto.
  simpl. intros g h Hg.
  destruct Hg as (h1&h2&?&?&?). subst h.
  exists___. splits~.

  eauto.te app_local_1. eauto.
  simpl.
  intros g h Hg. 
  intuit Hg. subst h.
  exists___. splits. eauto. skip.


 specializes H4 x2.



  unfold app_2. 
  unfolds app_2.
  simpl. rewrite local_local.

skip.
Qed.
*)

let _ = 
   let f() = [|1|] in (* "a", String.copy "a", [| 1 |] *)
   print_string (if f() == f() then "same" else "diff");
   print_newline()


(** Constructions *)

Notation "emp" := (heap_empty) 
  (at level 0) : heap_scope.




(** Basic facts about lists *)

Lemma In_app_l : forall (A:Type) L1 L2, 
  In A L1 -> In A (L1 ++ L2).
Proof. intros. induction L1; simpls. false. destruct* H. Qed.

Lemma In_app_2 : forall (A:Type) L1 L2, 
  In A L2 -> In A (L1 ++ L2).
Proof. intros. induction L1; simpls*. Qed.

Hint Resolve In_app_l In_app_2.


Definition rep_from_eq : forall A, Rep A A.
Proof. intros. apply (Build_Rep eq). congruence. Defined.


Axiom lt_to_le : forall x y : T,
  x < y -> x <= y.
Hint Immediate lt_to_le.
(* todo: refaire sans ça 

Definition rep_spec_2 (a1 a2 A1 A2 B : Type)
  (rep1:a1->A1->Prop) (rep2:a2->A2->Prop)
  (RK:a1->a2->A1->A2->~~B->Prop) f :=
  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> RK x1 x2 X1 X2 R) f.

Definition rep_spec_2_hyp (a1 a2 A1 A2 B : Type)
  (rep1:a1->A1->Prop) (rep2:a2->A2->Prop) (P:A1->A2->Prop)
  (RK:a1->a2->A1->A2->~~B->Prop) f :=
  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> P X1 X2 -> RK x1 x2 X1 X2 R) f.

Axiom rep_induction_mut_2_2_2 : 
  forall (a11 a12 A11 A12 B1 : Type)
  (rep11:a11->A11->Prop) (rep12:a12->A12->Prop)
  (mu1:A11->A12->nat) (RK1:a11->a12->A11->A12->~~B1->Prop) f1,
  forall (a21 a22 A21 A22 B2 : Type)
  (rep21:a21->A21->Prop) (rep22:a22->A22->Prop)
  (mu2:A21->A22->nat) (RK2:a21->a22->A21->A22->~~B2->Prop) f2,
  let IH := (fun n => 
      rep_spec_2_hyp (B:=B1) rep11 rep12 (fun X11 X12 => (mu1 X11 X12 < n)%nat) RK1 f1
   /\ rep_spec_2_hyp (B:=B2) rep21 rep22 (fun X21 X22 => (mu2 X21 X22 < n)%nat) RK2 f2) in
  rep_spec_2_hyp (B:=B1) rep11 rep12 (fun X11 X12 => IH (mu1 X11 X12)) RK1 f1 -> 
  rep_spec_2_hyp (B:=B2) rep21 rep22 (fun X21 X22 => IH (mu2 X21 X22)) RK2 f2 -> 
     rep_spec_2 (B:=B1) rep11 rep12 RK1 f1 
  /\ rep_spec_2 (B:=B2) rep21 rep22 RK2 f2.

intros. sets_eq n: (length Q).
gen a A H x1 Q. apply~ good_induct; clears n.
introv IH. intros ? ? ? q Q RQ NE N. subst n.

*)


Definition min_of (E:multiset T) (X:T) := 
  X \in E /\ forall_ Y \in E, X <= Y.

Definition removed_min (E E':multiset T) :=
  exists X, min_of E X /\ E = \{X} \u E'.

  (* todo : inversion for fset 

Lemma in_node_cases : forall (X Y : T) (A B : LibSet.set T),
  X \in \{Y} \u A \u B -> 
  X = Y \/ X \in A \/ X \in B.
Proof.
  introv H. destruct (in_union_inv H) as [H'|H'].
    left. rewrite~ (in_single H').
    right. destruct (in_union_inv H'); eauto.
Qed.
*)

Lemma in_node_cases : forall (X Y : T) (A B : LibSet.set T),
  X \in \{Y} \u A \u B -> 
  X = Y \/ X \in A \/ X \in B.
Proof.
  introv H. destruct (in_union_inv H) as [H'|H'].
    left. rewrite~ (in_single H').
    right. destruct (in_union_inv H'); eauto.
Qed.


Class Model (A:Type) := 
  { model : Type }.

Implicit Arguments model [[Model]].

Notation "# A" := (model A) (at level 30).

Class Rep `{Model A} := 
  { rep : A -> model A -> Prop;
    rep_unique : forall x X Y, rep x X -> rep x Y -> X = Y }.

Implicit Arguments Rep [[H]].
Implicit Arguments Build_Rep [A [H]].

Instance nat_model : Model nat := nat.
Hint Unfold nat_model.

Definition k := #nat.
Eval hnf in k.
Parameter y : #nat.
Check (y : nat).
(*pas général
Lemma convert : nat -> model nat.
Proof. exact (@id _). Qed.
Coercion convert : nat >-> model.
*)
Parameter x : nat.
(* fails: Check (x : #nat). *)

Lemma test : forall (x : nat) (X : nat), rep x X.

Instance nat_rep : Rep nat.
Proof. apply (Build_Rep (@eq _)). congruence. Defined.



------------



Record repr (A:Type) :=
  { model :> Type;
    rep : A -> model -> Prop;
    rep_unique : forall x X Y, rep x X -> rep x Y -> X = Y }.

Lemma nat_repr : @repr nat.
Proof. apply (Build_repr (@eq _)). congruence. Defined.

Canonical Structure nat_repr.

Class Rep A := 
  { repr_of : repr A }.

Instance nat_rep : Rep nat := nat_repr.

Notation "# A" := (@repr_of A _) (at level 30).

Parameter y : #nat.
Check (y: nat).

Parameter x :nat.
Check (x: #nat).


Notation "# A" := (@model A _) (at level 30).



Lemma test : int = #int :> Type. reflexivity. Qed.
Parameter y :#int.
Check (y: int).

Parameter x :int.
Check (x: #int).


Program Lemma test' : forall (x:int) (X :#int), x = (X:int) :> int.





(* todo: where to define these in order to avoid copy-paste ? 
tester: min_of A `{Le A} (E:multiset A) (X:A).
dans LibMultiset.

Definition min_of (E:multiset T) (X:T) := 
  X \in E /\ forall_ Y \in E, X <= Y.

Definition removed_min (E E':multiset T) :=
  exists X, min_of E X /\ E = \{X} \u E'.

Hint Unfold removed_min.
*)


Ltac name_around e x :=
  pattern e; match goal with |- ?P _ => sets x: P end.

Definition spec_hyp_2 (A1 A2 B : Type)
  (P:A1->A2->Prop) (K:A1->A2->~~B->Prop) f :=
  spec_2 (fun x1 x2 R => P x1 x2 -> K x1 x2 R) f.

(*
Lemma spec_hyp_size : forall (A1 A2 : Type) (mu:A1->A2->nat) (B : Type)
  (P:A1->A2->Prop) (K:A1->A2->~~B->Prop) f,
  is_spec
  (forall n, spec_hyp_2 (fun x1 x2 => n = mu x1 x2) K f) ->
  spec_2 K f.
*)


(*
Inductive intbar :=
  | intbar_int : int -> intbar
  | intbar_inf : intbar.

Instance intbar_le : Le intbar := fun (x y : intbar) => 
  match x,y with
  | intbar_int n, intbar_int m => n <= m
  | intbar_inf, intbar_int n => False
  | _, intbar_inf => True
  end.

(* todo: generic min *)

Ltac simpl_intbar_le :=
  repeat match goal with H: (@le intbar _ _ _) |- _ =>
    simpl in H end.
   
Axiom min : int -> int -> int.

Definition min_intbar (x y : intbar) :=
  match x,y with
  | intbar_int n, intbar_int m => intbar_int (min n m)
  | intbar_int n, _ => intbar_int n
  | _, intbar_int n => intbar_int n
  | _,_ => intbar_inf
  end.

Axiom min_trans_elim : forall a b x y : int,
  min a b <= x -> y <= a -> y <= b -> y <= x.
  *)



(*

Coercion intbar_int : Z >-> intbar.
Notation "'oo'" := intbar_inf.

Definition Rank_hd (ts:heap) :=
  match ts with
  | nil => oo
  | t::ts => Rank t
  end.
*)


Definition rep_spec_2_hyp (a1 a2 A1 A2 B : Type)
  (rep1:a1->A1->Prop) (rep2:a2->A2->Prop) (P:A1->A2->Prop)
  (RK:a1->a2->A1->A2->~~B->Prop) f :=
  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> P X1 X2 -> RK x1 x2 X1 X2 R) f.

Lemma conj_strengthen_2 : forall (Q1 Q2 P1 P2 : Prop),
  (Q1 -> P1) -> (Q2 -> P2) -> (Q1 /\ Q2) -> (P1 /\ P2).
Proof. auto*. Qed.

Lemma rep_spec_2_size : forall A1 A2 (mu:A1->A2->nat) 
  (a1 a2 B : Type) (rep1:a1->A1->Prop) (rep2:a2->A2->Prop) 
  (RK:a1->a2->A1->A2->~~B->Prop) f,
  (forall n, rep_spec_2_hyp rep1 rep2 (fun X1 X2 => mu X1 X2 = n) RK f) ->
  rep_spec_2 rep1 rep2 RK f.
Proof.
  introv H.
  unfolds. xintros.  unfolds. split. xweaken. unfolds rep_spec_2_hyp. eapply H. xintros.
Qed.

  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> P X1 X2 -> RK x1 x2 X1 X2 R) f.

Lemma merge_spec : RepTotal merge (E1;heap) (E2;heap) >>
  E1 \u E2 ; heap.
Proof.
  applys (>>> proj1 __ link_spec).
  eapply conj_strengthen_2; try intros M.
  

  eapply rep_induction_mut_2_2_2 with 
   (mu1 := fun E1 E2 => (2 * (card E1 + card E2) + 1)%nat)
   (mu2 := fun E1 E2 => (2 * (card E1 + card E2))%nat);
   unfold rep_spec_2, rep_spec_2_hyp.
  (* verif merge *)
  xcf. introv R1 R2 [_ IH]. xmatch; xcleanpat.
  xgo. inverts R2. equates* 1.
  xgo. inverts R1. equates* 1.
  inverts R1. inverts R2. xapp~. xif.
    xapp~.
    applys_to P_x0 nle_to_sle. xapp~. ximpl. equates* 1.
  (* verif link *)
  xcf. intros h1 h2 E1 E2 R1 R2 [IH _] X MX GX. inverts R1. 
  xgo. applys_to MX proj1. eapply (in_empty X). eauto.
  xmatch.
  xgo. inverts H0. forwards~: (>>> min_of_eq MX). constructors*.
  xgo~. forwards~: (>>> min_of_eq MX). constructors*.
Qed.




(*
Lemma testing: 
  forall a A B (P:a->A->Prop) (K:a->A->~~B->Prop) (f:val),
  True ->
  spec_1 (fun x R => forall X, P x X -> K x X R) f.
Admitted.
*)
(*
Lemma min_of_eq : forall X Y E1 E2,
  min_of (\{Y} \u E1 \u E2) X ->
  foreach (is_ge X) E1 ->
  foreach (is_ge X) E2 ->
  X <= Y.
Proof.
  introv [M1 M2] G1 G2. multiset_in M1.
  apply le_refl.
  apply~ M2.
  apply~ M2.
Qed.
*)


(*
Lemma test : (BagEmpty (multiset T)).
typeclass. Qed.
Lemma test2 : (BagCard (multiset T)).
typeclass. Qed.
Lemma test23 : @card_empty (multiset T) _ _ _ = card_empty.
typeclass. Qed.
*)

(*
Definition sum_measure A1 A2 (mu1:A1->nat) (mu2:A2->nat) (p:A1+A2) : nat :=
  match p with 
  | inl x => mu1 x 
  | inr x => mu2 x 
  end.
  (*(sum_measure (fun h1 h2 => 2 * (size h1 + size h2)) (fun h size).*)

Definition size_pair (p:heap*heap) :=
  let (h1,h2) := p in (size h1 + size h2)%nat.
*)
(*
  sets lt: (fun p1 p2 => match p1,p2 with
    | inl x, inr y => size_pair x < size_pair y
    | inr x, inl y => size_pair x <= size_pair y
    | _,_ => False end).
*)

Lemma spec_induction_mut_2_2_2 : 
  forall A11 A12 B1 A21 A22 B2 (lt:binary(A11*A12+A21*A22)),
  forall (Wf: wf lt) f1 f2 (K1:A11->A12->~~B1->Prop) (K2:A21->A22->~~B2->Prop),
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => lt (inl (y1,y2)) (inl (x1,x2)) -> K1 y1 y2 R') f1 ->
    spec_2 (fun y1 y2 R' => lt (inr (y1,y2)) (inl (x1,x2)) -> K2 y1 y2 R') f2 ->
    K1 x1 x2 R) f1 ->
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => lt (inl (y1,y2)) (inr (x1,x2)) -> K1 y1 y2 R') f1 ->
    spec_2 (fun y1 y2 R' => lt (inr (y1,y2)) (inr (x1,x2)) -> K2 y1 y2 R') f2 ->
    K2 x1 x2 R) f2 ->
  spec_2 K1 f1 /\ spec_2 K2 f2.
Admitted.
*)

(*
Definition link_spec := Spec link h1 h2 |R>>
  forall E1 E2,
  inv h1 E1 ->
  inv h2 E2 ->
  forall x ho hs X Eo Es,
  h1 = Node x ho hs ->
  rep x X ->
  inv ho Eo ->
  inv hs Es ->
  foreach (is_ge X) Eo ->
  foreach (is_ge X) Es ->
  foreach (is_ge X) E2 ->
  R (\{X} \u Eo \u Es \u E2 ; heap).
*)
(*
Definition link_spec := RepSpec link (E1;heap) (E2;heap) |R>>
  forall x h1 ho hs X Eo Es,
  rep x X ->
  inv ho Eo ->
  inv hs Es ->
  h1 = Node x ho hs ->
  foreach (is_ge X) Eo ->
  foreach (is_ge X) Es ->
  foreach (is_ge X) E2 ->
  R (\{X} \u Eo \u Es \u E2 ; heap).
*)

(*
Definition is_rep_root X E :=
  match E with
  | Empty => False
  | Node x ho hs => rep x X 
  end.
*)

(* todo: simplify using rep_unique *)



(*-- old

Hint Extern 1 (RegisterSpec link) => Provide link_spec.

Lemma merge_spec : RepTotal merge (E1;heap) (E2;heap) >>
  E1 \u E2 ; heap.
Proof.
  xcf. introv R1 R2. xmatch; xcleanpat.
  xgo. inverts R2. equates* 1.
  xgo. inverts R1. equates* 1.
  inverts R1. inverts R2. xapp~. xif.
  xapp~. ximpl. equates* 1.
  applys_to P_x0 nle_to_sle. xapp~. ximpl. equates* 1.
Qed.

Hint Extern 1 (RegisterSpec merge) => Provide merge_spec.

Lemma link_spec : Spec link h1 h2 |R>>
  forall x ho hs X Eo Es E2,
  h1 = Node x ho hs ->
  rep x X ->
  inv ho Eo ->
  inv hs Es ->
  inv h2 E2 ->
  foreach (is_ge X) Eo ->
  foreach (is_ge X) Es ->
  foreach (is_ge X) E2 ->
  R (\{X} \u Eo \u Es \u E2 ; heap).
Proof.
  xcf. introv Sh1 Rx Ro Rs R2 Lo Ls L2.
  xmatch; inverts H.
  xgo. inverts Ro. constructors*.
  xgo~. constructors*.
Qed.

Hint Extern 1 (RegisterSpec link) => Provide link_spec.

*)


(*
Definition spec_measure_2 
  A1 A2 B (size:A1->A2->nat)
  f (K:A1->A2->~~B->Prop) :=
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => (size y1 y2 < size x1 x2)%nat -> K y1 y2 R') f ->
    K x1 x2 R) f.

Let measure_for2 : forall 
  A11 A12 B1 (size1:A11->A12->nat) f1 (K1:A11->A12->~~B1->Prop) 
  A21 A22 B2 (size2:A21->A22->nat) f2 (K2:A12->A22->~~B2->Prop),
  
(P Q : nat -> Prop),
  (forall n, (forall m, m < n -> P n))

  (forall n, P n /\ Q n).
*)

Lemma merge_spec : RepTotal merge (E1;heap) (E2;heap) >>
  E1 \u E2 ; heap.
Proof.
  xintros. intros h1 h2. intros. sets_eq n: ((size h1 + size h2)%nat).
  gen EQn. gen h1 h2 E1 E2. pattern n.
  match goal with |- ?P _ => sets m_spec: P end.
  applys (>>> proj1 __ (link_spec (S n))). move n after m_spec.
  induction n using peano_induction. rename H into IH. split. 
  (* verif merge *)
  unfolds. clears. introv R1 R2 N. xcf_app. xmatch; xcleanpat.
  xgo. inverts R2. equates* 1.
  xgo. inverts R1. equates* 1.
  inverts R1. inverts R2.
   simpl in N. forwards (_&K): (IH ((n-1)%nat)). math. unfolds in K.
   xapp~. xif.
     xapp~. ximpl. equates* 1.
     applys_to P_x0 nle_to_sle. xapp~. ximpl. equates* 1.
  (* verif link *)
  unfolds. xcf. introv Sh1 Rx Ro Rs R2 Lo Ls L2 N.
  forwards (K&_): (IH ((size h + size a)%nat)). skip. 
   unfolds in K. clears.
  xmatch; inverts H.
  xgo. inverts Ro. constructors*. simpl in K.
  xgo~. xapp. constructors*.
Qed.

(*


Axiom factorize : forall (P1 P2 P3 P4 P5 : nat -> Prop),
  (forall n, P1 n /\ P2 n /\ P3 n /\ P4 n /\ P5 n) ->
  (forall n, P1 (n)) /\ (forall n, P2 (n)) /\ (forall n, P3 (n))
    /\ (forall n, P4 (n))  /\ (forall n, P5 (n)).

Lemma eq_gt_induction_5' : forall (P1 P2 P3 P4 P5 : (nat->Prop) -> Prop),
  eq_gt_implies P1 -> eq_gt_implies P2 -> eq_gt_implies P3 -> 
  eq_gt_implies P4 -> eq_gt_implies P5 ->
  (forall n, P1 (gt n) -> P2 (gt n) -> P3 (gt n) -> P4 (gt n) -> P5 (gt n) -> 
    P1 (eq n) /\ P2 (eq n) /\ P3 (eq n) /\ P4 (eq n) /\ P5 (eq n)) ->
  (forall n, P1 (eq n) /\ P2 (eq n) /\ P3 (eq n) /\ P4 (eq n) /\ P5 (eq n)).
Proof. 
  introv H1 H2 H3 H4 H5 R.
  induction n using peano_induction. apply R;
    match goal with K: eq_gt_implies ?Pi |- ?Pi _ =>
      apply K; intros; forwards*: H; try math end.
Qed. 

Axiom go :forall (P1 P2 P3 P4 P5 : (nat->Prop) -> Prop),
 (forall n, P1 (eq n) /\ P2 (eq n) /\ P3 (eq n) /\ P4 (eq n) /\ P5 (eq n)).
(*
Lemma conj_strengthen_5' : forall (Q1 Q2 Q3 Q4 Q5 P1 P2 P3 P4 P5 : (nat -> Prop) -> Prop),
  (Q1 -> P1) -> (Q2 -> P2) -> (Q3 -> P3) -> (Q4 -> P4) -> (Q5 -> P5) ->
  (Q1 /\ Q2 /\ Q3 /\ Q4 /\ Q5) -> (P1 /\ P2 /\ P3 /\ P4 /\ P5).
Proof. auto*. Qed.
*)

(*
Axiom go' :forall (P1 : (nat->Prop) -> Prop),
 (forall n, P1 (eq n)).

Axiom go'' :forall f n  (P1 P2 : (nat->Prop) -> Prop),
 (f = eq n -> (P1 f /\ P2 f)).
*)
*)

(* todo: move *)




(*
  eapply rep_induction_mut_2_2_2 with 
   (mu1 := fun E1 E2 => (2 * (card E1 + card E2) + 1)%nat)
   (mu2 := fun E1 E2 => (2 * (card E1 + card E2))%nat);
   unfold rep_spec_2, rep_spec_2_hyp.
*)

(*
Hint Extern 1 (@gt nat _ _ _) => check_noevar tt; simpl; rew_card; math.
*)


(*
Ltac all_specs_go :=
  unfolds; first [ xintros; instantiate;  
    [ xcf; auto; 
      try match goal with H: Rep ?a _ |- _ => instantiate (1 := a) end;
      try xisspec | ]
  | xintros ].
*)





(* todo: remove this
Ltac xcurried_core ::=
  let arity := spec_goal_arity tt in
  let lemma := get_curried_prove_x arity in
  eapply lemma; try solve [ xcf; auto; instantiate; 
    try (check_noevar_goal; xisspec) ].
 *)



(* todo: move *)
Lemma Forall2_unique : forall A1 A2 (P:A1->A2->Prop) l L1 L2,
  (forall x X Y, P x X -> P x Y -> X = Y) -> 
  Forall2 P l L1 -> Forall2 P l L2 -> L1 = L2.
Proof.
  induction l; introv H H1 H2; inverts H1; inverts H2; prove_rep.
Qed.

Hint Resolve Forall2_unique : rep.





(* bin:
Lemma inv_nil_change : forall rs rs' Es, 
  inv rs nil Es -> 0 <= rs' -> inv rs' nil Es.
Proof. introv H P. inverts~ H. Qed.


Definition Rank_hd_or r (ts:heap) :=
  match ts with
  | nil => r
  | t::ts => Rank t
  end.

Lemma le_rank_hd_or_elim : forall r ts,
  r <= Rank_hd_or r ts ->
  r <= Rank_hd ts.
Proof. intros. destruct ts.

Lemma inv_smallest : forall rs ts Es,
  inv rs ts Es -> 
  exists rs',
  inv rs' ts Es /\
  rs' <= rs /\
  (ts = nil -> rs' = 0).
Proof.
  introv H. inverts H. exists~ 0.
  exists rs. splits. auto~. auto~. auto_false.
Qed. (* todo: improve autofalse *)


Lemma remove_min_tree_spec : Spec remove_min_tree (ts:heap) |R>>
  forall rs Es, inv rs ts Es -> Es <> \{} -> 
  R (fun o => let (t',ts') := o : tree * heap in
     exists E' Es' X r' rs', 
       btree r' t' E' /\
       inv rs' ts' Es' /\
       Es = E' \u Es' /\
       rep (Root t') X /\
       foreach (is_ge X) Es /\ 
       rs <= rs').
Proof.
(*
  xinduction (@List.length tree). xcf. introv IH RH NE. xmatch.
  xgo. inverts RH. false.
  xgo. inverts RH as Rt R0. inverts R0. 
    lets (X&RX&MX): (root_le_all Rt). subst Es. exists~ ___.
  lets (rs0&E0&Ez&Rt&Rts&K1&K2&EQ): (inv_cons_inv RH). clear RH.
  asserts: (Ez <> \{}). intro_subst_hyp.
    destruct ts. inverts Rts. false. inverts Rts as BT. lets: (btree_not_empty BT).
    skip. (*fsetinv*)
  xapp~. destruct _x1 as [t' ts'].
   destruct P_x1 as (E'&Es'&X&r'&rs'&Rt'&Rts'&EQ'&RX&MX&D).
  xmatch. xapp~. xapp~. cbv beta in *. subst _x3 _x4. 
  lets (Y&RY&MY): (root_le_all Rt). xgo~.
  subst Es. exists~ ___.
  subst Es Ez. applys_to P_x2 nle_to_sle. 
    exists E' (E0 \u Es') __ __ __. splits~. permut_simpl.
*) skip.
Qed.

Hint Extern 1 (RegisterSpec remove_min_tree) => Provide remove_min_tree_spec.

Lemma find_min_spec : RepSpec find_min (E;heap) |R>>
  E <> \{} -> R (min_of E ;; O.t).
Proof.
  xcf. intros e E RepE HasE. simpl in RepE. xgo~.
  destruct P_x0 as (E'&Es'&X&r'&rs'&Rt'&Rts'&EQ'&RX&MX&D).
  ximpl as x Px. subst x. skip: (X \in E). eauto. 
  (* todo: rep_unique to solve this *)
Qed.

Hint Extern 1 (RegisterSpec find_min) => Provide find_min_spec.

Lemma delete_min_spec : RepSpec delete_min (E;heap) |R>>
  E <> \{} -> R (removed_min E ;; heap).
Proof. 
  xcf. introv Rts NE. simpl in Rts. xapp~. xmatch.
  destruct P_x0 as (E'&Es'&X&r'&rs'&Rt'&Rts'&EQ'&RX&MX&D).
  simpl in RX. clear H.
  asserts: (_p0 = r'). inverts~ Rt'. subst.
    forwards~ (Er&I'&EQ'): (>>> inv_rev_children_final x ts1).
  xapp~.  
    sapply~ inv_rank_smaller.
    ximpl as h Ph.
  exists (Er \u Es'). split~. subst E'. exists* X.
Qed.

Hint Extern

*)


(** termination relation *)
(* we could use a size function as well *)

Inductive subtree : set -> set -> Prop :=
  | subtree_left : forall col a x b, subtree a (Node col a x b)
  | subtree_right : forall col a x b, subtree b (Node col a x b).

Hint Constructors subtree.

Lemma subtree_wf : wf subtree.
Proof.
  intros e. induction e;
    constructor; introv H; inversions~ H.
Qed.

Hint Resolve subtree_wf : wf.


Inductive subtree : set -> set -> Prop :=
  | subtree_left : forall a x b, subtree a (Node a x b)
  | subtree_right : forall a x b, subtree b (Node a x b).

Hint Constructors subtree.

Lemma subtree_wf : wf subtree.
Proof.
  intros e. induction e;
    constructor; introv H; inversions~ H.
Qed.

Hint Resolve subtree_wf : wf.

  xinduction (unproj22 elem subtree).  


(* todo: move *)
Lemma Forall2_unique : forall A1 A2 (P:A1->A2->Prop) l L1 L2,
  (forall x X Y, P x X -> P x Y -> X = Y) -> 
  Forall2 P l L1 -> Forall2 P l L2 -> L1 = L2.
Proof.
  induction l; introv H H1 H2; inverts H1; inverts H2; prove_rep.
Qed.

Hint Resolve Forall2_unique : rep.

(*todo:move
Definition rep_from_eq : forall A, Rep A A.
Proof. intros. apply (Build_Rep eq). congruence. Defined.
*)

(*
Lemma rep_null : forall `{Rep a A},
  rep Null (@nil A).
Proof. exists~ __. Qed.
Hint Resolve @rep_null.
*)


     (* todo : or patterns 
        let balance = function
     | (Black, Node (Red, Node (Red, a, x, b), y, c), z, d) ->
       Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
     | (Black, Node (Red, a, x, Node (Red, b, y, c)), z, d) ->
       Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
     | (Black, a, x, Node (Red, Node (Red, b, y, c), z, d)) ->
       Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
     | (Black, a, x, Node (Red, b, y, Node (Red, c, z, d))) ->
       Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
     | (c,a,x,y) -> Node (c,a,x,y)

*)




(*

Lemma inv_weaken : forall p ts L,
  inv false p ts L -> inv true p ts L.
Proof. introv M. inverts M; constructors~. Qed.

Hint Resolve @inv_weaken.

(* todo: use next one *)
Lemma inv_strengthen : forall p ts L T,
  inv true p ts (T++L) -> T <> nil -> inv false p ts (T++L).
Proof.
  introv M. gen_eq L':(T++L). gen T L. induction M; intros; subst.
  false H0. destruct~ (nil_eq_app_inv H).
  constructors~.
  constructors~.
Qed.

Lemma inv_strengthen' : forall p ts L,
  inv true p ts L -> L <> nil -> inv false p ts L.
Proof.
  introv M. induction M; intros; subst; tryfalse; auto~.
Qed.


Lemma inv_strengthen'' : forall p ts L,
  inv true p ts L -> ts <> nil -> inv false p ts L.
Proof.
  introv M. induction M; intros; subst; tryfalse; auto~.
Qed.



Hint Resolve @btree_not_empty.
(*Hint Resolve @inv_strengthen.*)

*)
Hint Extern 1 (@rep (rlist _) _ _ _ _) => simpl.



(*
Lemma inv_size_pos : forall p ts L,
  inv p ts L -> p >= 0.
Proof. introv Rts. induction Rts; unfolds eq'. auto. math.  Qed.
Hint Resolve btree_size_pos.
*)

(* needed?
Lemma btree_zero_inv : forall t L,
  btree 0 t L -> exists x, t = Leaf x.
Proof. 
  introv H. inverts H. eauto.
  lets: (btree_size_pos H0). math.
Qed.
*)

  (* applys* (>>> inv_node (\{Y0} \u A0 \u B0) Y (\{X} \u B \u E2)).*)
(*  applys* (>>> inv_node (\{Y} \u A \u A0) Y0 (\{X} \u B0 \u E2)). *)



    xgo~ '_x4 XstopAfter, '_x3 XstopAfter.
    xapp~. destruct~ col; destruct (node_color a); tryifalse; auto.
    ximpl as e. simpl. destruct col. subst. equates* 1.

    forwards~ M: (>>> inv_weaken' (match col with Black => false | Red => true end)).
      intro; destruct col; destruct (node_color a); destruct Col; tryfalse; auto.
     clear P_x4. xapp~. destruct~ col.
     ximpl as e. simpl. destruct col; subst; equates* 1.
    forwards~ M: (>>> inv_weaken' (match col with Black => false | Red => true end)).
      intro; destruct col; destruct (node_color b); destruct Col; tryfalse; auto.
     clear P_x3. xapp~. destruct~ col.
     ximpl as e. simpl. destruct col; subst; equates* 1.




(*
Definition head_spec := proj53 all_specs.
Definition tail_spec := proj54 all_specs.
Definition snoc_spec := proj55 all_specs.
*)

(*bin

Definition snoc_specs `{Rep a A} :=
  Spec snoc (q:queue a) (x:a) |R>>
     forall X Q, rep x X -> rep q Q ->
     R (fun q' => rep q' (Q&X)).



    (* case empty *)
    clear PN3 IHsnoc. subst m Qm. inverts H11. 
    rew_concat in *. rew_length in H18. 
    apply app_spec_1. apply~ checkf_cf. xisspec.
    intros b B. subst b. xmatch. xmatch.
      xret. inverts H9. inverts P3.
      specializes IHhead (>>> (list a) (rev Qr :: nil)). xapp~. clear IHhead.
      xlet (= Empty (A:=list a)). apply app_spec_1. apply~ tail_cf. xisspec.
       intros b B. subst b. rewrite~ PE3. xmatch.
      apply app_spec_1. apply~ checkq_cf. xisspec.
       intros b B. subst b. xmatch. xif; try math.
      apply app_spec_1. apply~ checkf_cf. xisspec.
       intros b B. subst b q. xmatch. xmatch. xret~. false~ C3.
      subst _x0. xret. xrep in P_x2. inverts H9. subst Q.
       rew_list. rew_length in *. inverts PX as M. inverts M.
         constructors~. rew_length~. rew_list~. simpl in RX.
         intro_subst_hyp. inverts RX as M. applys_to M nil_eq_rev_inv.
          subst Qr. rew_length in *. math.
      xret. constructors~. rew_list~. rew_list~. intro_subst_hyp. false~ C1.
       apply~ doubling_cons. rew_length~.
    (* case not empty *)
    clear PE3 IHhead. 
    xapp. constructors~. subst Qm. rew_list~. subst Q Qm. rew_list~.
    apply~ doubling_last. subst Qm. rew_length~.
    simpl. rewrite~ PN3.

*)

(* bin: check needed

Lemma decrease_r : forall A (Q Qf Qm Qr : list A) Qms,
  Q = Qf ++ Qm ++ rev Qr ->
  0 < length Qr -> 
  Qm = concat Qms ->
  doubling true 1 Qms ->
  length Qms < length Q.
Proof.
  introv E L Em Dm. destruct Qr. gen L. rew_list~. 
  forwards: (concat_doubling_length Dm).
  subst Q Qm. rew_length~.
Qed.

Lemma decrease_f : forall `{Rep a A} f (Q Qf Qm Qr : list A) Qms,
  Q = Qf ++ Qm ++ rev Qr ->
  f <> nil -> rep f Qf ->
  Qm = concat Qms ->
  doubling true 1 Qms ->
  length Qms < length Q.
Proof.
  introv E L R Em Dm. destruct f. false. inverts R.
  forwards: (concat_doubling_length Dm).
  subst Q Qm. rew_length~.
Qed.
 *)


(*bin
Fixpoint depth a (q:queue a) : nat :=
  match q with
  | Empty => 0%nat

  

Ltac xapp_compact KR args :=
  let args := ltac_args args in
  match args with (boxer ?mode)::?vs => 
  let args := constr:((boxer mode)::(boxer KR)::vs) in
  constr:(args)
  end.

Ltac xapp_inst args solver :=
  let R := fresh "R" in let LR := fresh "L" R in 
  let KR := fresh "K" R in let IR := fresh "I" R in
  intros R LR KR;
  let H := xapp_compact KR args in
  forwards IR: H; solver tt; try sapply IR. 



  eapply local_wframe.
     [ try xlocal
     | eapply K; [ apply H | idtac ] 
     | hsimpl 
     | xok ].
  xapp_inst (>>>) ltac:(fun _ => eauto).
  
  eapply local_wframe; 
     [ xlocal
     | eapply K; [ apply H | idtac ] 
     | hsimpl 
     | xok ].
  xapp_inst (>>>) ltac:(fun _ => eauto).
  intros R LR KR.
   forwards IR: (>>> KR); eauto; try sapply IR. hsimpl.






xapp_manual.

Qed.
 lenfm f m lenr r => (1 + depth m)%nat
  end.
*)


(** Full garbage collection on postcondition from [local] 

Lemma local_gc_post_all : forall B Q (F:~~B) H HG (P:B->Prop),
  is_local F -> 
  Q ===> \[P] \*+ HG ->
  F H Q ->
  F H (\[P]).
Proof. intros. apply* local_gc_post. Qed.

Tactic Notation "xgc_post_all" := 
  eapply local_gc_pre with (H' := H);
    [ try xlocal
    | hsimpl
    | ].

*)



Lemma xret_lemma : forall B (v:B) H (Q:B->hprop),
  (\= v \*+ H) ===> Q -> 
  local (fun H Q => H heap_empty /\ Q v heap_empty) H Q.
Proof.  
  introv W. applys local_wframe B [] H (\= v). (* todo: instantiate *)
  simpls. auto.
  apply local_erase. split. reflexivity. hnfs~. hsimpl. auto.
Qed.


   




  (* détails de xapp
  xapp_manual. applys KR. hsimpl.

  xfind ml_ref; let H := fresh in intro H.
  lets K: spec_elim_1_1.
  xapp_manual as.
  xapp_inst (>>>) ltac:(fun _ => eauto).
  hsimpl.
  *)





(* bin *)
Lemma hsimpl_prop_1 : forall (P1:Prop),
  P1 -> [] ==> [P1].
Proof. introv H K. (*surprenant: destruct K.*)
  skip. (* todo *)
Qed.




Lemma local_wframe' : forall B H1 H2 Q1 (F:~~B) H Q,
  is_local F -> 
  H ==> H1 \* H2 -> 
  F H1 Q1 -> 
  Q1 \*+ H2 ===> Q ->
  F H Q.
Proof. intros. apply* local_wframe. Qed.

Lemma local_gc_post' : forall H' B (F:~~B) H Q,
  is_local F -> 
  F H (Q \*+ H') ->
  F H Q.
Proof. intros. apply* local_gc_post. Qed.



Lemma hclean_exists : forall B (F:~~B) H1 H2 A (J:A->hprop) Q,
  is_local F -> 
  (forall x, F ((H1 \* (J x)) \* H2) Q) ->
   F (H1 \* (heap_is_pack J \* H2)) Q.
Proof. 
  intros. rewrite star_comm_assoc. apply~ local_intro_exists.
  intros. rewrite star_comm_assoc. rewrite~ star_assoc. 
Qed. 



Lemma post_le_unit : forall H H' : hprop,
  H ==> H' -> (#H) ===> (#H').
Proof. intros_all~. Qed.


Lemma xfor_frame__ : forall I H' a b H Q (Fof:int->~~unit),
  (forall i, is_local (Fof i)) ->
  (a > (b)%Z -> H ==> (Q tt)) ->
  ((a <= (b)%Z) -> 
      (H ==> I a \* H') 
   /\ (forall i, a <= i /\ i <= (b)%Z -> (Fof i) (I i) (# I(i+1))) 
   /\ (I ((b)%Z+1) \* H' ==> Q tt)) ->
  local (fun H Q => (a > (b)%Z -> H ==> (Q tt)) /\ (a <= (b)%Z -> exists I,
     H ==> I a /\ (forall i, a <= i /\ i <= (b)%Z -> (Fof i) (I i) (# I(i+1))) /\ (I ((b)%Z+1) ==> Q tt))) H Q.
Proof.
  introv L M1 M2. apply local_erase. split. auto.
  introv M3. intuit (M2 M3). exists (I \*+ H'). splits*.
  intros i Hi. specializes H1 Hi. apply* local_wframe.
Qed.

Lemma xfor_frame_le__ : forall I H' a b H Q (Fof:int->~~unit),
  (a <= (b)%Z) -> 
  (H ==> I a \* H') ->
  (forall i, a <= i /\ i <= (b)%Z -> (Fof i) (I i) (# I(i+1))) ->
  (I ((b)%Z+1) \* H' ==> Q tt) ->
  local (fun H Q => (a > (b)%Z -> H ==> (Q tt)) /\ (a <= (b)%Z -> exists I,
     H ==> I a /\ (forall i, a <= i /\ i <= (b)%Z -> (Fof i) (I i) (# I(i+1))) /\ (I ((b)%Z+1) ==> Q tt))) H Q.
Proof.
  introv M1 M2 M3 M4. apply~ (>>> local_wframe unit __ H' (fun _:unit => I (b+1))).
  apply local_erase. split. intros. false. math.
  intros. exists* I. intros t. destruct t. auto.
Qed.



(*
Lemma temp2 : forall (H:hprop),
  H ==> (fun _ => H) tt.
Proof. auto. Qed.
*)



Parameter ml_ref_spec : forall a,
  Specs ml_ref (v:a) >> [] (~> RefOn v).

Parameter ml_get_spec : forall a,
  Spec ml_get (l:loc) |R>> 
    forall v:a, read R (l ~> RefOn v) (\=v).

Parameter ml_set_spec : forall a,
  Spec ml_set (l:loc) (v:a) |R>> 
    forall v':a, R (l ~> RefOn v') (# l ~> RefOn v).
 
   
 (*| _ =>  
          match TX with 
          | TX => fail 1
          | _ => let K := fresh "TEMP" in sets_eq K: (X : ltac_tag_subst hprop)
          end*)


Ltac protect_evars_in H ::=
   match H with context [ ?X ] =>
     let go tt := 
       match X with
       | _ \* _ => fail 1
       | X => fail 1 
       | ?x ~> ?R => 
           match x with x =>
           (*
          let doit m :=
             let Tm := type of m in
             let K := fresh "TEMP" in sets_eq K: (m : ltac_tag_subst Tm);
             change K with (ltac_tagged K) in
          match x with 
          | x => match R with R  doit R
          | ltac_tagged _ => doit R
          | _ => doit x
          end*)

       | _ ~>  => fail 1
       | ?R ~> _ => let TR := type of R in
           let K := fresh "TEMP" in sets_eq K: (R : ltac_tag_subst TR);
           change K with (ltac_tagged K)
       | _ ~> ?R => let TR := type of R in
           let K := fresh "TEMP" in sets_eq K: (R : ltac_tag_subst TR);
           change K with (ltac_tagged K)
       | _ => let K := fresh "TEMP" in sets_eq K: (X : ltac_tag_subst hprop)
       end in
     match type of X with 
     | hprop => go tt
     | heap -> Prop => go tt
     end
  end.

Ltac protect_evars tt ::=
  do 5 try match goal with |- ?H1 ==> ?H2 =>
     first [ protect_evars_in H1 | protect_evars_in H2 ]; instantiate
  end; unfold ltac_tagged. 

Ltac protect_evars_in H ::=
   match H with context [ ?X ] =>
     let go tt := 
       match X with
       | _ \* _ => fail 1
       | X => fail 1 
       | ?x ~> ?R => 
           match x with
           | x => idtac             
           | _ => fail 20 "Uninstantiated argument at left of ~>"
           end;
           let TR := type of R in
           let K := fresh "TEMP" in 
           sets_eq K: (R : ltac_tag_subst TR)
       | _ => let K := fresh "TEMP" in
              sets_eq K: (X : ltac_tag_subst hprop)
       end in
     match type of X with 
     | hprop => go tt
     | heap -> Prop => go tt
     end
  end.




Lemma esplit_boolof : forall (b:bool) (H:hprop) (P:(bool->hprop)->Prop),
  P (\= b \*+ H) -> ex P.
Proof. intros. exists (\= b \*+ H). applys_eq H0 1. extens~. Qed.

Ltac xwhile_body_manual :=
  let x := fresh "X" in intros x; xextract;
  pose ltac_mark; intros; apply local_erase; gen_until_mark.

Ltac xwhile_body_handle :=
  intros; eapply esplit_boolof; splits.

Ltac xwhile_core I R X := 
  first [ eapply (@xwhile_frame _ I R)
        | eapply (@xwhile_frame _ I (measure R))];
  [ xlocal
  | xlocal
  | try prove_wf
  | exists X; instantiate; hsimpl 
  | try xwhile_body_manual (* ; try xwhile_body_handle*)
  | hsimpl ].

Ltac xwhile_manual_core I R := 
  first [ eapply (@xwhile_frame _ I R)
        | eapply (@xwhile_frame _ I (measure R))];
  [ xlocal
  | xlocal
  | idtac
  | idtac
  | try xwhile_body_manual
  | idtac ].


Tactic Notation "xwhile" constr(I) constr(R) constr(X) := 
  xwhile_core I R X.
Tactic Notation "xwhile" constr(I) constr(R) := 
  xwhile I R __.
Tactic Notation "xwhile_manual" constr(I) constr(R) := 
  xwhile_manual_core I R.


Ltac xfor_frame_side tt := 
  let H' := fresh in let PH' := fresh in
  let i := fresh in let Pi := fresh in
  intros H' PH' i Pi; eapply local_frame; 
   [try xlocal | apply PH'; apply Pi ].


Ltac xfor_core I := 
  let Hi := fresh "Hfor" in
  eapply (@xfor_frame I); 
  [ try solve [ xfor_frame_side tt ]
  | intros Hfor; try solve [ false; math ]
  | intros Hfor; splits (3%nat); 
     [ hsimpl 
     | xfor_bounds_intro tt
     | hsimpl ] 
  ].

Ltac xfor_le_core I :=
  eapply (@xfor_frame_le I);
  [ try math
  | xfor_bounds_intro tt
  | hsimpl ].

Tactic Notation "xfor" constr(I) := 
  xfor_core I.

Tactic Notation "xfor_le" constr(I) := 
  xfor_le_core I.




Notation "'Hexists' x1 x2 , H" := (Hexists x1, Hexists x2, H)
  (at level 39, x1 ident, x2 ident, H at level 50) : heap_scope.
Notation "'Hexists' x1 x2 x3 , H" := (Hexists x1, Hexists x2, Hexists x3, H)
  (at level 39, x1 ident, x2 ident, x3 ident, H at level 50) : heap_scope.
Notation "'Hexists' x1 x2 x3 , H" := (Hexists x1, Hexists x2, Hexists x3, Hexists x4, H)
  (at level 39, x1 ident, x2 ident, x3 ident, x4 ident, H at level 50) : heap_scope.

Notation "'keep' R H Q" :=
  (R H (Q \*+ H)) (at level 25, R at level 0, H at level 0, Q at level 0).



(*
Fixpoint List A a (T:A->a->hprop) (L:list A) (l:loc) : hprop :=
  match L with
  | nil => [True]
  | X::L' => Hexists x l', T X x \* l ~> RefOn (x,l') \* List T L' l'
  end.
*)

(* 
Ltac hchange_core H :=
  first [ apply (@hchange_lemma H)
        | applys hchange_lemma H ]; 
  hsimpl.



Ltac xchange_lemma_core L :=
  eapply xchange_lemma; 
    [ try apply local_is_local
    | applys L
    | hsimpl
    | ].


(*
Definition pred_le' := pred_le.
Lemma pred_le_change : pred_le = pred_le'.
Proof. auto. Qed.
Opaque pred_le'.

Ltac xchange_lemma_core L ::=
  let K := fresh "TEMP" in
  let K' := fresh "TEMP" in
  lets K: L; 
  rewrite pred_le_change in K;
  forwards K': K;
  rewrite <- pred_le_change in K;
  clear K;
  eapply xchange_lemma; 
    [ clear K'; try apply local_is_local
    | apply K'
    | clear K'; instantiate; try hsimpl
    | clear K' ].
*)





Axiom spec_induction_2_noarg : 
  forall A1 A2 B A0 (lt:binary A0),
  forall (Wf: wf lt) f (L:A0->A1->A2->~~B->Prop),
  (forall y, is_spec_2 (L y)) ->
  spec_2 (fun x1 x2 R => forall x0,
    spec_2 (fun y1 y2 R' => forall y0, 
      lt y0 x0 -> L y0 y1 y2 R') f ->
    L x0 x1 x2 R) f ->
  spec_2 (fun x1 x2 R => forall x0, L x0 x1 x2 R) f.

Axiom spec_induction_3_noarg : 
  forall A1 A2 A3 B A0 (lt:binary A0) (Wf: wf lt) f 
         (L:A0->A1->A2->A3->~~B->Prop),
  (forall y, is_spec_3 (L y)) ->
  spec_3 (fun x1 x2 x3 R => forall x0,
    spec_3 (fun y1 y2 y3 R' => forall y0,
      lt y0 x0 -> L y0 y1 y2 y3 R') f ->
    L x0 x1 x2 x3 R) f ->
  spec_3 (fun x1 x2 x3 R => forall x0, L x0 x1 x2 x3 R) f.

Axiom spec_induction_4_noarg : 
  forall A1 A2 A3 A4 B A0 (lt:binary A0) (Wf: wf lt) f 
         (L:A0->A1->A2->A3->A4->~~B->Prop),
  (forall y, is_spec_4 (L y)) ->
  spec_4 (fun x1 x2 x3 x4 R => forall x0,
    spec_4 (fun y1 y2 y3 y4 R' => forall y0,
       lt y0 x0 -> L y0 y1 y2 y3 y4 R') f ->
    L x0 x1 x2 x3 x4 R) f ->
  spec_4 (fun x1 x2 x3 x4 R => forall x0, L x0 x1 x2 x3 x4 R) f.







(*test*)

Definition pureapp' A B (F:val) (V:A) (P:B->Prop) :=
  app_1 F V [] \[P].

Definition spec_2' A1 A2 B (K: A1 -> A2 -> ~~B -> Prop) f :=
  is_spec_2 K /\ forall x1, pureapp' f x1 (spec_1 (K x1)).

Definition curried_2' (A1 A2 B:Type) f := 
  spec_2' (fun (x1:A1) (x2:A2) (R:~~B) => True) f.


Lemma spec_intro_2 : forall A1 A2 B f (K:A1->A2->~~B->Prop),
  is_spec_2 K ->
  curried_2' A1 A2 B f ->
  (forall x1 x2, K x1 x2 (app_2 f x1 x2)) ->
  spec_2' K f.
Proof.
  introv I C HK. split~.
  intros x1.
  lets U: (proj2 C x1). unfolds pureapp'.
  applys local_weaken U. skip. skip. intros g.
  hextract. hsimpl.
  split. skip. intros x2. applys I. apply HK.
  intros H Q Ap.
  apply local_name_heap. skip.
  intros h Hh. specializes Ap Hh.
  destruct Ap as (H1&H2&Q1&H'&?&(Q'&Ap1&Ap2)&Po).
  hnf in Ap1.
  destruct H3 as (h1&h2&?&?&H5&H6).
  specializes Ap1 h1 h2 __ __. auto. auto.
  destruct Ap1 as (v'&h'&g'&D'&Re&Ev).

  hnf. intros h_ i D'' E. hnf in E. subst h_.
  exists___. splits 3%nat. skip. skip. 

  applys local_wgframe Po. skip. apply Ap2.
  intros h'. intro_subst.
  hnf in U.
  specializes 

  intros h i Dhi Hh.
  specializes Ap Hh.
  destruct Ap as (H1&H2&Q1&H'&?&(Q'&Ap1&Ap2)&Po).
  destruct H3 as (h1&h2&?&?&H5&H6).
  specializes Ap1 h1 (h2 \+ i) __ __. skip. auto. (* todo*)
  destruct Ap1 as (v'&h'&g'&D'&Re&Ev).
  exists v'. (h' \+ h2).
    

 hnf.

 destruct (pureapp_witness (proj2 C x1)) as [g [_ Hg]].
  apply* pureapp_abstract. split~. intros x2. eapply I.
  apply HK.
  intros H Q M.
  rewrite app_local_1. introv Hh.
  destruct (M _ Hh) as (H1&H2&Q1&H'&?&(Q'&Ap1&Ap2)&Po).
  specializes Ap2 g.
  destruct H0 as (h1&h2&?&?&?&?).
  forwards* (H''&Ro): (>>> (@pureapp_and_app_1) f x1).
  exists (Q' g \* H'') H2 __ (H' \* H''). splits.
    subst. exists___*.
    apply* local_wframe.
    intros r. specializes Po r. hsimpl. auto.
Admitted. (* existentials *)




Lemma unfocus_mnil : forall (l:loc) A,
  l ~> @Mlist A nil ==> [l = null].
Proof. intros. simpl. hdata_simpl. hsimpl~. Qed.




(*
Ltac hclean_on contH contQ :=
  match goal with
  | |- _ ?H ?Q => contH H; contQ Q
  | |- _ _ ?H ?Q => contH H; contQ Q
  | |- _ _ _ ?H ?Q => contH H; contQ Q
  | |- _ _ _ _ ?H ?Q => contH H; contQ Q
  end.
*)



(* deprecated 

Ltac protect_evars_in H :=
   match H with context [ ?X ] => 
     let go tt := 
       match X with
       | _ \* _ => fail 1
       | _ ~> _ => fail 1
       | X => fail 1 
       | _ => let K := fresh "TEMP" in sets_eq K: (X : ltac_tag_subst hprop)
       end in
     match type of X with 
     | hprop => go tt
     | heap -> Prop => go tt
     end
   end.

Ltac protect_evars_in H ::=
   match H with context [ ?X ] =>
     let go tt := 
       match X with
       | _ \* _ => fail 1
       | X => fail 1 
       | ?x ~> ?R => 
           match x with
           | x => idtac             
           | _ => fail 20 "Uninstantiated argument at left of ~>"
           end;
           let TR := type of R in
           let K := fresh "TEMP" in 
           sets_eq K: (R : ltac_tag_subst TR)
       | _ => let K := fresh "TEMP" in
              sets_eq K: (X : ltac_tag_subst hprop)
       end in
     match type of X with 
     | hprop => go tt
     | heap -> Prop => go tt
     end
  end.

*)

(*
Ltac hsimpl_assoc_rhs tt :=
  let M := fresh "TEMP" in
  match goal with |- ?H ==> ?H' =>
    sets M: H'; autorewrite with hsimpl_assoc; subst M
  end.
hsimpl_assoc_rhs tt.*)


(*--deprecated
Ltac hsimpl_find_data H HL :=
  match H with hdata _ ?l =>
  match HL with
  | hdata _ l \* _ => apply hsimpl_cancel_1
  | _ \* hdata _ l \* _ => apply hsimpl_cancel_2
  | _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_3
  | _ \* _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_4
  | _ \* _ \* _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_5
  | _ \* _ \* _ \* _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_6
  end end.
*)


(* todo: bin
Lemma heap_disjoint_union_r : forall h1 h2 h3,
  heap_disjoint h1 h2 -> heap_disjoint h1 h3 ->
  heap_disjoint h1 (heap_union h2 h3).
Proof.
Qed.

Lemma heap_disjoint_union_inv_r : forall h1 h2 h3,
  heap_disjoint h1 (heap_union h2 h3) ->
  heap_disjoint h1 h2 /\ heap_disjoint h1 h3.
Proof.
  intros [f1 F1] [f2 F2] [f3 F3] M.
  unfolds heap_disjoint, heap_union. simpls.
  unfolds pfun_disjoint, pfun_union. 
  split; intros x; specializes M x; 
   destruct (f2 x); intuition. false.
Qed.

Lemma heap_disjoint_union_inv_l : forall h1 h2 h3,
  heap_disjoint (heap_union h2 h3) h1 ->
  heap_disjoint h1 h2 /\ heap_disjoint h1 h3.
Proof. introv H. apply~ heap_disjoint_union_inv_r. Qed.
*)



(** Star with post-conditions (predicates of type [B->hprop]) 

Definition starpost B (Q:B->hprop) (H:hprop) : B->hprop :=
  fun x => heap_is_star (Q x) H.
*)
(*bin
Notation "\= V" := (\[ = V])
  (at level 40) : heap_scope.
*)

(*
Notation "l '~~~>' v" := (heap_is_single l v)
  (at level 35, no associativity) : heap_scope.
*)




Definition heaps_union (hs : list heap) : heap :=
  LibList.fold_right heap_union heap_empty hs.

(** Heap well-defineteness *)

Definition heap_defined (h : heap) : Prop :=
  h <> None.
 
(** Heap disjointness *)

Definition heaps_disjoint (hs : list heap) : Prop :=
  heap_defined (heaps_union hs).

Notation "\# h1 h2 h3" := (heaps_disjoint (h3::h2::h1::nil))
  (at level 40, h1 at level 0, h2 at level 0, h3 at level 0, no associativity).
*)
(*
Lemma test : forall h1 h2 h3, (\# h1 h2) = (\# h1 h2) /\ (\# h1 h2 h3) = (\# h1 h2 h3).
*)


(*
Lemma app_intro_prop_1 : forall (U:Prop) A B (F:val) (V:A) (H:hprop) (Q:B->hprop),
  (H ==> [U]) -> (U -> app_1 F V H Q) -> app_1 F V H Q.
Proof.
  introv W M. eapply local_intro_prop.
Qed.
*)
