############################################################################
############################################################################
# Garbage

# -- todo: add support for user provided mli files

# @sed -i 's/\.cmo/.cmi/g' $@
#	@sed -e 's/.*://' -e 's/\\$$//' < $@.tmp | fmt -1 | \
#	  sed -e 's/^ *//' -e 's/$$/:/' >> $@  

# .SECONDARY: %.ml.d %.v.d %.cmi %.cmo %.vo %.ml.d %.v.d %.cmi %_ml.v %_ml.v.d %_ml.vo %.byte

#gen/stdlib/pervasives.cmi: gen/stdlib/pervasives.mli $(MYOCAMLCMI)
#	$(MYOCAMLCMI) -nostdlib -nopervasives $<
#gen/stdlib/%.cmi: gen/stdlib/%.mli gen/stdlib/pervasives.cmi $(MYOCAMLCMI)
#	$(MYOCAMLCMI) -nostdlib -I gen/stdlib $<


#$(MYOCAMLDEP) $(INCLUDES) $<  > $@
#'s/\($*\)\.o[ :]*/\1/g'

#'\''s/\($*\)\.o[ :]*/\1.o $@ : /g'\'' > $@
#
#	$(MYOCAMLDEP) $(INCLUDES) $< > $@
#	@cp -f $@ $@.tmp
#	@sed -e 's/.*://' -e 's/\\$$//' < $@.tmp | fmt -1 | \
#	  sed -e 's/^ *//' -e 's/$$/:/' >> $@  
#	@rm -f $@.tmp


# make sure that you first do
#   chmod +x ocamldep.wrapper 
#   chmod +x go.sh

# you might also need "chmod +x *.byte" when you recompile



#%.byte: $(GENERATOR_SRC)
#	@rm -f camllib/*.cmi camllib/*.ml.d || echo ok

# $(IMPER:=.cmi) in DEPENDENCIES

############################################################################
############################################################################




(* todo?
Lemma Id_focus : forall A (x n : A),
  x ~> Id n ==> [x = n].
Proof. intros. unfold Id. hdata_simpl. hextract. hsimpl~. Qed.

Lemma Id_unfocus : forall A (x : A),
  [] ==> x ~> Id x.
Proof. intros. unfold Id. hdata_simpl. hextract. hsimpl~. Qed.

Implicit Arguments Id_focus [A].
Implicit Arguments Id_unfocus [A].
*)


(*
Notation "'exists' ( x1 : T1 ) ',' P" :=
  (exists x1:T1, P)
  (at level 200, x1 ident, 
   right associativity) : type_scope. 
Notation "'exists' ( x1 : T1 ) ( x2 : T2 ) ',' P" :=
  (exists x1:T1, exists x2:T2, P)
  (at level 200, x1 ident, x2 ident, 
   right associativity) : type_scope.  
Notation "'exists' ( x1 : T1 ) ( x2 : T2 ) ( x3 : T3 ) ',' P" :=
  (exists x1:T1, exists x2:T2, exists x3:T3, P)
  (at level 200, x1 ident, x2 ident, x3 ident, 
   right associativity) : type_scope. 
Notation "'exists' ( x1 : T1 ) ( x2 : T2 ) ( x3 : T3 ) ( x4 : T4 ) ',' P" :=
  (exists x1:T1, exists x2:T2, exists x3:T3, exists x4:T4, P)
  (at level 200, x1 ident, x2 ident, x3 ident, x4 ident, 
   right associativity) : type_scope. 
*)


Record dynamic := dyn {_type : Type; 
  dyn_value : dyn_type }.

Inductive heap_c : Type :=
| empty_c : heap_c
| cons_c : nat -> dynamic -> heap_c -> heap_c.

Definition array A := nat -> A -> Prop.
Definition map A B := A -> B -> Prop.
Definition map' := map.
Definition heap := map nat dynamic.
Definition f (y:array nat) := dyn y.
Require Import List.
Print list.
(* map nat nat*)




Definition map A B := A -> B.
Definition heap := map nat dynamic.
Definition f (y:map nat nat) := 
  fun x:nat => dyn y.


(*
Proof.
  intro. extens. intros H Q. iff M.
  apply~ local_erase.
  introv Hh. destruct (M _ Hh) as (H1&H2&Q1&H'&R&N&?).
  lets (h1&h2&?&?&?&?): R. clear R.
  destruct~ (N h1) as (H1'&H2'&Q1'&?&?&?).
  exists H1' (H2 \* H2') Q1'.
  splits~. rewrite (star_comm H2). rewrite star_assoc. exists h1 h2. splits~.
  intros g. specializes H9 g.
  rewrite (star_comm H2). rewrite star_assoc.
  apply* local_wgframe.
Qed.
*)
(*
  introv Hh. destruct (M _ Hh) as (H1&H2&Q1&H'&R&N&?).
  destruct R as (h1&h2&?&?&?&?).
  destruct~ (N h1) as (Q'&?&?).
  exists (Q' \*+ H2). split.
  rewrite app_local_1. introv Hh'.
  apply* local_wframe.
*)

(*
  destruct M as (H1&H2&Q1&H'&?&(Qg&?&Hg)&?).
  exists (fun g => Qg g ** H2). splits.
    apply* local_frame.
    intros. specializes Hg g. apply* local_elim.
*)




(*  forall h, H h ->
  exists H1 H2 Q1, 
     (H1 \* H2) h 
  /\ app_1 f x1 H1 Q1 
  /\ forall g, app_1 g x2 (Q1 g \* H2) Q.
*)

(*
  forall h, H h ->
  exists Q', app_1 f x1 H Q' 
          /\ forall g, app_1 g x2 (Q' g) Q.
*)


(********************************************************************)
(* ** OLD Axioms *)

(** The type Func *)

Axiom val : Type. 

(** The type Func is inhabited *)

Axiom val_inhab : Inhab val. 
Existing Instance val_inhab.

(** The predicate AppReturns *)

Axiom app_1 : forall A B,  
  val -> A -> hprop -> (B -> hprop) -> Prop.

(** The predicate AppPure *)

Axiom pureapp : forall A B,  
  val -> A -> (B -> Prop) -> Prop.

(** AppReturns is a local property *)

Axiom app_local_1 : forall B A1 (x1:A1) f,
  is_local (app_1 (B:=B) f x1). 

(** AppPure satisfies the witness property *)

Axiom pureapp_concrete : forall A B (F:val) (V:A) (P:B->Prop),
  pureapp F V P <-> exists V', P V' /\ pureapp F V (= V').

(** AppPure satisfies the determinacy property *)

Axiom pureapp_deterministic : forall A B (F:val) (V:A) (V1' V2':B),
  pureapp F V (= V1') -> pureapp F V (= V2') -> V1' = V2'.          

(** From AppPure to AppReturns *)

Axiom pureapp_to_app : forall A B (F:val) (V:A) (P:B->Prop),
  pureapp F V P -> app_1 F V [] \[P].
  (* Could also be stated: [pureapp F V ==> pure (app_1 F V)] *)

(** Overlapping of AppPure and AppReturns *)

Axiom pureapp_and_app : forall A B (F:val) (V:A) (V':B) (H:hprop) (Q:B->hprop),
  pureapp F V (= V') -> app_1 F V H Q -> (H ==> Q V').



(********************************************************************)
(* ** Low-level axioms *)

(** The type of terms *)

Axiom trm : Type. 

(** The type Func *)

Axiom val : Type. 

(** The type Func is inhabited *)

Axiom val_inhab : Inhab val. 
Existing Instance val_inhab.

(** The construction of applications *)

Axiom app_trm : forall A, val -> A -> trm. (* todo: as relation *)

(** The evaluation predicate: [eval t h v h'] *)

Axiom eval : forall A, trm -> heap -> A -> heap -> Prop.

(** Evaluation is deterministic *)

Axiom eval_deterministic : forall A t h (v1 v2:A) h1 h2,
  eval t h v1 h1 -> eval t h v2 h2 -> v1 = v2 /\ h1 = h2.
  


Lemma hdata_unfold : forall (l l' : loc) (P:loc->hprop),
  hdata (fun l' => P l') l = hdata P l.
Proof. auto. Qed.



(*
Lemma hclean_end : forall B (F:~~B) H Q,
  is_local F -> F ([] \* H) Q -> F H Q.
Proof. intros. rew_heap in *. auto. Qed.
*)



Definition heap_is_single (l:loc) A (P:A->Prop) : hprop := 
  fun h => exists v, h = heap_single l v /\ P v.


(********************************************************************)
(* ** Locality *)

(*------------------------------------------------------------------*)
(* ** Definition of [local] *)

(** Type of post-conditions on values of type B *)

Notation "'~~' B" := (hprop->(B->hprop)->Prop) 
  (at level 8, only parsing) : type_scope.

(** "Local" = Frame rule + consequence rule + garbage collection *)

Definition local B (F:~~B) : ~~B :=
  fun (H:hprop) (Q:B->hprop) =>
    exists H1 H2 Q1 H',
       H ==> H1 * H2
    /\ F H1 Q1
    /\ forall x, (Q1 x) * H2 ==> (Q x) * H'.

(** Characterization of "local" judgments *)

Definition is_local B (F:~~B) :=
  F = local F.

(** The weakening property is implied by locality *)

Definition weakenable B (F:~~B) :=
  forall H Q , F H Q ->
  forall H' Q', H' ==> H -> Q ===> Q' -> F H' Q'.


(*------------------------------------------------------------------*)
(* ** Properties of [local] *)

(** The [local] operator can be freely erased from a conclusion *)

Lemma local_erase : forall B (F:~~B), 
  forall H Q, F H Q -> local F H Q.
Proof.
  intros. exists H [] Q []. splits.
  rew_heap~. auto. auto.
Qed.

(** Nested applications [local] are redundant *)

Lemma local_local : forall B (F:~~B),
  local (local F) = local F.
Proof.
  extens. intros H Q. iff M. 
  destruct M as (H1&H2&Q1&H'&?&N&?).
  destruct N as (H1'&H2'&Q1'&H''&?&?&?).
  exists H1' (H2 ** H2') Q1' (H' ** H''). splits.
  eapply pred_le_trans. eauto.
   intros h Hh. hnf in Hh. destruct Hh as (h1&h2&?&?&?&?).
   subst h. applys_to H9 H4. intuit H9. subst h1.
   rewrite (star_comm H2). rewrite star_assoc.
   exists __ __. splits~. exists __ __. splits~.
  eauto.
  intros.
  skip. (* todo *)
  apply~ local_erase.
Qed.

(** A definition whose head is [local] satisfies [is_local] *)

Lemma local_is_local : forall B (F:~~B),
  is_local (local F).
Proof. intros. unfolds. rewrite~ local_local. Qed.

(** Elimination lemma associated with the definition of [local] *)

Lemma local_elim : forall B (F:~~B) H H1 H2 H' Q1 Q,
  is_local F -> 
  F H1 Q1 -> 
  H ==> H1 ** H2 -> 
  Q1 *** H2 ===> Q *** H' ->
  F H Q.
Proof.
  introv L M WH WQ. rewrite L. exists H1 H2 Q1 H'. splits.
  auto. auto. intros. rew_heap~. apply WQ.
Qed.

(** Corrolary for the case where no garbage collection is required *)

Lemma local_frame : forall B (F:~~B) H H1 H2 Q1 Q,
  is_local F -> 
  F H1 Q1 -> 
  H ==> H1 ** H2 -> 
  Q1 *** H2 ===> Q ->
  F H Q.
Proof.
  intros. eapply local_elim with (H' := []); eauto. rew_heap~.
Qed.

(** Corrolary for the case where no frame is required *)

Lemma local_weaken : forall B (F:~~B) H H' Q Q',
  is_local F -> 
  F H' Q' -> 
  H ==> H' -> 
  Q' ===> Q ->
  F H Q.
Proof.
  intros. eapply local_frame with (H2 := []); eauto; rew_heap~.
Qed.

Lemma local_weaken' : forall B (F:~~B),
  is_local F -> weakenable F.
Proof. intros_all. apply* local_weaken. Qed.
  (* todo: use only one lemma *)


Definition local' B (F:~~B) : ~~B :=
  fun (H:hprop) (Q:B->hprop) =>
    exists H1 H2 P Q1 H',
       H ==> H1 * H2 * [P]
    /\ (P -> F H1 Q1)
    /\ forall x, (Q1 x) * H2 ==> (Q x) * H'.

Lemma local_intro_prop : forall B (F:~~B) H1 H2 (P:Prop) Q,
  is_local F -> (P -> F (H1 * H2) Q) -> F (H1 * [P] * H2) Q.
Proof.
  introv L M. rewrite L.
  skip_rewrite (local = local').
  exists (H1 * H2) [] P Q []. splits.
  skip. (* heaps *)
  auto.
  auto.
Qed. 

Lemma local_intro_exists : forall B (F:~~B) H1 H2 A (J:A->hprop) Q,
  is_local F -> (forall x, F (H1 * (J x) * H2) Q) ->
   F (H1 * heap_is_pack J * H2) Q.
Proof.
  introv L M. rewrite L.
  skip_rewrite (local = local').
  exists (H1 * H2) [] True Q []. splits.
  skip. (* heaps *)
  auto.
  auto.
Qed. 





(* don't do those, cause need to use spec_elim_3_2 directly
   to know partial apps have no effects
Lemma app_intro_3_2 :
  app_3 f x1 x2 x3 H Q ->
  (exists Q', app_2 f x1 x2 H Q' 
           /\ forall g, app_1 g x3 (Q' g) Q) ->

  app_2 f x1 x2 H (fun g h => app_1 g x3 (= h) Q).
Proof. skip. Qed.
*)

(*

Lemma app_intro_1_2 : 
  app_1 f x1 H (fun g h => app_1 g x2 (= h) Q) ->
  app_2 f x1 x2 H Q.
Proof.
  introv M. hnf. esplit. split. eauto.
  intros.
(*
  introv M. exists H [] __ []. splits.
    rew_heap~.
    apply M.
    intros x K S. rew_heap~ in *.
*)
Qed.

Lemma app_intro_2_1 : 
  app_2 f x1 x2 H Q ->
  app_1 f x1 H (fun g h => app_1 g x2 (= h) Q).
Proof.
  introv M. rewrite app_local_1.
  intuit M. exists___*.
Qed.

Lemma app_intro_2_3 : 
  app_2 f x1 x2 H (fun g h => app_1 g x3 (= h) Q) ->
  app_3 f x1 x2 x3 H Q.
Proof. skip. Qed.

Lemma app_intro_2_4 : 
  app_2 f x1 x2 H (fun g h => app_2 g x3 x4 (= h) Q) ->
  app_4 f x1 x2 x3 x4 H Q.
Proof. skip. Qed.

Lemma app_intro_3_1 : 
  app_3 f x1 x2 x3 H Q ->
  app_1 f x1 H (fun g h => app_2 g x2 x3 (= h) Q).
Proof. skip. Qed.

Lemma app_intro_3_2 :
  app_3 f x1 x2 x3 H Q ->
  app_2 f x1 x2 H (fun g h => app_1 g x3 (= h) Q).
Proof. skip. Qed.

Lemma app_intro_3_4 : 
  app_3 f x1 x2 x3 H (fun g h => app_1 g x4 (= h) Q) ->
  app_4 f x1 x2 x3 x4 H Q.
Proof. skip. Qed.

Lemma app_intro_4_1 :
  app_4 f x1 x2 x3 x4 H Q ->
  app_1 f x1 H (fun g h => app_3 g x2 x3 x4 (= h) Q).
Proof. skip. Qed.

Lemma app_intro_4_2 :
  app_4 f x1 x2 x3 x4 H Q ->
  app_2 f x1 x2 H (fun g h => app_2 g x3 x4 (= h) Q).
Proof. skip. Qed.

Lemma app_intro_4_3 :
  app_4 f x1 x2 x3 x4 H Q ->
  app_3 f x1 x2 x3 H (fun g h => app_1 g x4 (= h) Q).
Proof. skip. Qed.

*)


Lemma app_intro_2_3' : 
  (exists Q', app_2 f x1 x2 H Q' 
           /\ forall g, app_1 g x3 (Q' g) Q) ->
  app_3 f x1 x2 x3 H Q.
Proof. 
  introv (Q2&(Q1&M1&M2)&M3).
  exists Q1. split~. intros g. exists~ Q2.
Qed.


(********************************************************************)
(* ** Corrolaries from locality *)

(* AppReturns satisfies the weakening property *)

Lemma app_weaken_1 : forall B A1 (x1:A1) f,
  @weakenable B (app_1 f x1).
Proof. intros. apply~ local_weaken'. Qed.

(* todo: other needed?*)


Lemma curried_1_true : forall A1 B f, curried_1 A1 B f.
Proof. split. intros_all~. auto. Qed. 



(********************************************************************)
(* ** Weakenability of app *)

(* automatic from local_weaken

Lemma app_weakenable_1 : forall A1 B f x1,
  weakenable (@app_1 A1 B f x1).
Proof. intros_all. apply~ (app_weaken_1 H). Qed.

Lemma app_weakenable_2 : forall A1 A2 B f x1 x2,
  weakenable (@app_2 A1 A2 B f x1 x2).
Proof.
   intros_all. apply (app_weaken_1 H). 
   intros_all. applys* app_weakenable_1.
Qed.

Lemma app_weakenable_3 : forall A1 A2 A3 B f x1 x2 x3,
  weakenable (@app_3 A1 A2 A3 B f x1 x2 x3).
Proof.
   intros_all. apply (app_weaken_1 H). 
   intros_all. applys* app_weakenable_2.
Qed.

Lemma app_weakenable_4 : forall A1 A2 A3 A4 B f x1 x2 x3 x4,
  weakenable (@app_4 A1 A2 A3 A4 B f x1 x2 x3 x4).
Proof.
   intros_all. apply (app_weaken_1 H). 
   intros_all. applys* app_weakenable_3.
Qed.

Hint Resolve app_weakenable_1 app_weakenable_2 
  app_weakenable_3 app_weakenable_4.

*)



(*app_weaken_1;
  intros. introv M WH WQ. rewrite app_local_1.
  exists H [] Q []. splits. 
  rew_heap~.
  auto.
  intros. rew_heap~.
*)


(*
Definition app_2 A1 A2 B f (x1:A1) (x2:A2) (H:hprop) (Q:B->hprop) := 
  app_1 f x1 H (fun g h' => app_1 g x2 (= h') Q).

Definition app_3 A1 A2 A3 B f (x1:A1) (x2:A2) (x3:A3) (H:hprop) (Q:B->hprop) := 
  app_1 f x1 H (fun g h' => app_2 g x2 x3 (= h') Q).

Definition app_4 A1 A2 A3 A4 B f (x1:A1) (x2:A2) (x3:A3) (x4:A4) (H:hprop) (Q:B->hprop) := 
  app_1 f x1 H (fun g h' => app_3 g x2 x3 x4 (= h') Q).
*)


(* old
Lemma app_local_2 : forall B A1 A2 (x1:A1) (x2:A2) f,
  (app_2 f x1 x2) = @local B (app_2 f x1 x2).
Proof.
  intros. extens. intros H Q. iff M.
  apply~ local_erase.
  destruct M as (H1&H2&Q1&H'&?&?&?).
  unfolds app_2. 
  rewrite app_local_1.
  exists H1 (H2 ** H') __ []. splits.
  auto.
  eauto.
  simpl. intros g h Hg.
  destruct Hg as (h1&h2&?&?&?). subst h.
  exists___. splits~.

  eauto.te app_local_1. eauto.
  simpl.
  intros g h Hg. 
  intuit Hg. subst h.
  exists___. splits. eauto. skip.


 specializes H4 x2.



  unfold app_2. 
  unfolds app_2.
  simpl. rewrite local_local.

skip.
Qed.
*)

let _ = 
   let f() = [|1|] in (* "a", String.copy "a", [| 1 |] *)
   print_string (if f() == f() then "same" else "diff");
   print_newline()


(** Constructions *)

Notation "emp" := (heap_empty) 
  (at level 0) : heap_scope.




(** Basic facts about lists *)

Lemma In_app_l : forall (A:Type) L1 L2, 
  In A L1 -> In A (L1 ++ L2).
Proof. intros. induction L1; simpls. false. destruct* H. Qed.

Lemma In_app_2 : forall (A:Type) L1 L2, 
  In A L2 -> In A (L1 ++ L2).
Proof. intros. induction L1; simpls*. Qed.

Hint Resolve In_app_l In_app_2.


Definition rep_from_eq : forall A, Rep A A.
Proof. intros. apply (Build_Rep eq). congruence. Defined.


Axiom lt_to_le : forall x y : T,
  x < y -> x <= y.
Hint Immediate lt_to_le.
(* todo: refaire sans ça 

Definition rep_spec_2 (a1 a2 A1 A2 B : Type)
  (rep1:a1->A1->Prop) (rep2:a2->A2->Prop)
  (RK:a1->a2->A1->A2->~~B->Prop) f :=
  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> RK x1 x2 X1 X2 R) f.

Definition rep_spec_2_hyp (a1 a2 A1 A2 B : Type)
  (rep1:a1->A1->Prop) (rep2:a2->A2->Prop) (P:A1->A2->Prop)
  (RK:a1->a2->A1->A2->~~B->Prop) f :=
  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> P X1 X2 -> RK x1 x2 X1 X2 R) f.

Axiom rep_induction_mut_2_2_2 : 
  forall (a11 a12 A11 A12 B1 : Type)
  (rep11:a11->A11->Prop) (rep12:a12->A12->Prop)
  (mu1:A11->A12->nat) (RK1:a11->a12->A11->A12->~~B1->Prop) f1,
  forall (a21 a22 A21 A22 B2 : Type)
  (rep21:a21->A21->Prop) (rep22:a22->A22->Prop)
  (mu2:A21->A22->nat) (RK2:a21->a22->A21->A22->~~B2->Prop) f2,
  let IH := (fun n => 
      rep_spec_2_hyp (B:=B1) rep11 rep12 (fun X11 X12 => (mu1 X11 X12 < n)%nat) RK1 f1
   /\ rep_spec_2_hyp (B:=B2) rep21 rep22 (fun X21 X22 => (mu2 X21 X22 < n)%nat) RK2 f2) in
  rep_spec_2_hyp (B:=B1) rep11 rep12 (fun X11 X12 => IH (mu1 X11 X12)) RK1 f1 -> 
  rep_spec_2_hyp (B:=B2) rep21 rep22 (fun X21 X22 => IH (mu2 X21 X22)) RK2 f2 -> 
     rep_spec_2 (B:=B1) rep11 rep12 RK1 f1 
  /\ rep_spec_2 (B:=B2) rep21 rep22 RK2 f2.

intros. sets_eq n: (length Q).
gen a A H x1 Q. apply~ good_induct; clears n.
introv IH. intros ? ? ? q Q RQ NE N. subst n.

*)


Definition min_of (E:multiset T) (X:T) := 
  X \in E /\ forall_ Y \in E, X <= Y.

Definition removed_min (E E':multiset T) :=
  exists X, min_of E X /\ E = \{X} \u E'.

  (* todo : inversion for fset 

Lemma in_node_cases : forall (X Y : T) (A B : LibSet.set T),
  X \in \{Y} \u A \u B -> 
  X = Y \/ X \in A \/ X \in B.
Proof.
  introv H. destruct (in_union_inv H) as [H'|H'].
    left. rewrite~ (in_single H').
    right. destruct (in_union_inv H'); eauto.
Qed.
*)

Lemma in_node_cases : forall (X Y : T) (A B : LibSet.set T),
  X \in \{Y} \u A \u B -> 
  X = Y \/ X \in A \/ X \in B.
Proof.
  introv H. destruct (in_union_inv H) as [H'|H'].
    left. rewrite~ (in_single H').
    right. destruct (in_union_inv H'); eauto.
Qed.


Class Model (A:Type) := 
  { model : Type }.

Implicit Arguments model [[Model]].

Notation "# A" := (model A) (at level 30).

Class Rep `{Model A} := 
  { rep : A -> model A -> Prop;
    rep_unique : forall x X Y, rep x X -> rep x Y -> X = Y }.

Implicit Arguments Rep [[H]].
Implicit Arguments Build_Rep [A [H]].

Instance nat_model : Model nat := nat.
Hint Unfold nat_model.

Definition k := #nat.
Eval hnf in k.
Parameter y : #nat.
Check (y : nat).
(*pas général
Lemma convert : nat -> model nat.
Proof. exact (@id _). Qed.
Coercion convert : nat >-> model.
*)
Parameter x : nat.
(* fails: Check (x : #nat). *)

Lemma test : forall (x : nat) (X : nat), rep x X.

Instance nat_rep : Rep nat.
Proof. apply (Build_Rep (@eq _)). congruence. Defined.



------------



Record repr (A:Type) :=
  { model :> Type;
    rep : A -> model -> Prop;
    rep_unique : forall x X Y, rep x X -> rep x Y -> X = Y }.

Lemma nat_repr : @repr nat.
Proof. apply (Build_repr (@eq _)). congruence. Defined.

Canonical Structure nat_repr.

Class Rep A := 
  { repr_of : repr A }.

Instance nat_rep : Rep nat := nat_repr.

Notation "# A" := (@repr_of A _) (at level 30).

Parameter y : #nat.
Check (y: nat).

Parameter x :nat.
Check (x: #nat).


Notation "# A" := (@model A _) (at level 30).



Lemma test : int = #int :> Type. reflexivity. Qed.
Parameter y :#int.
Check (y: int).

Parameter x :int.
Check (x: #int).


Program Lemma test' : forall (x:int) (X :#int), x = (X:int) :> int.





(* todo: where to define these in order to avoid copy-paste ? 
tester: min_of A `{Le A} (E:multiset A) (X:A).
dans LibMultiset.

Definition min_of (E:multiset T) (X:T) := 
  X \in E /\ forall_ Y \in E, X <= Y.

Definition removed_min (E E':multiset T) :=
  exists X, min_of E X /\ E = \{X} \u E'.

Hint Unfold removed_min.
*)


Ltac name_around e x :=
  pattern e; match goal with |- ?P _ => sets x: P end.

Definition spec_hyp_2 (A1 A2 B : Type)
  (P:A1->A2->Prop) (K:A1->A2->~~B->Prop) f :=
  spec_2 (fun x1 x2 R => P x1 x2 -> K x1 x2 R) f.

(*
Lemma spec_hyp_size : forall (A1 A2 : Type) (mu:A1->A2->nat) (B : Type)
  (P:A1->A2->Prop) (K:A1->A2->~~B->Prop) f,
  is_spec
  (forall n, spec_hyp_2 (fun x1 x2 => n = mu x1 x2) K f) ->
  spec_2 K f.
*)


(*
Inductive intbar :=
  | intbar_int : int -> intbar
  | intbar_inf : intbar.

Instance intbar_le : Le intbar := fun (x y : intbar) => 
  match x,y with
  | intbar_int n, intbar_int m => n <= m
  | intbar_inf, intbar_int n => False
  | _, intbar_inf => True
  end.

(* todo: generic min *)

Ltac simpl_intbar_le :=
  repeat match goal with H: (@le intbar _ _ _) |- _ =>
    simpl in H end.
   
Axiom min : int -> int -> int.

Definition min_intbar (x y : intbar) :=
  match x,y with
  | intbar_int n, intbar_int m => intbar_int (min n m)
  | intbar_int n, _ => intbar_int n
  | _, intbar_int n => intbar_int n
  | _,_ => intbar_inf
  end.

Axiom min_trans_elim : forall a b x y : int,
  min a b <= x -> y <= a -> y <= b -> y <= x.
  *)



(*

Coercion intbar_int : Z >-> intbar.
Notation "'oo'" := intbar_inf.

Definition Rank_hd (ts:heap) :=
  match ts with
  | nil => oo
  | t::ts => Rank t
  end.
*)


Definition rep_spec_2_hyp (a1 a2 A1 A2 B : Type)
  (rep1:a1->A1->Prop) (rep2:a2->A2->Prop) (P:A1->A2->Prop)
  (RK:a1->a2->A1->A2->~~B->Prop) f :=
  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> P X1 X2 -> RK x1 x2 X1 X2 R) f.

Lemma conj_strengthen_2 : forall (Q1 Q2 P1 P2 : Prop),
  (Q1 -> P1) -> (Q2 -> P2) -> (Q1 /\ Q2) -> (P1 /\ P2).
Proof. auto*. Qed.

Lemma rep_spec_2_size : forall A1 A2 (mu:A1->A2->nat) 
  (a1 a2 B : Type) (rep1:a1->A1->Prop) (rep2:a2->A2->Prop) 
  (RK:a1->a2->A1->A2->~~B->Prop) f,
  (forall n, rep_spec_2_hyp rep1 rep2 (fun X1 X2 => mu X1 X2 = n) RK f) ->
  rep_spec_2 rep1 rep2 RK f.
Proof.
  introv H.
  unfolds. xintros.  unfolds. split. xweaken. unfolds rep_spec_2_hyp. eapply H. xintros.
Qed.

  spec_2 (B:=B) (fun x1 x2 R => forall X1 X2, 
    rep1 x1 X1 -> rep2 x2 X2 -> P X1 X2 -> RK x1 x2 X1 X2 R) f.

Lemma merge_spec : RepTotal merge (E1;heap) (E2;heap) >>
  E1 \u E2 ; heap.
Proof.
  applys (>>> proj1 __ link_spec).
  eapply conj_strengthen_2; try intros M.
  

  eapply rep_induction_mut_2_2_2 with 
   (mu1 := fun E1 E2 => (2 * (card E1 + card E2) + 1)%nat)
   (mu2 := fun E1 E2 => (2 * (card E1 + card E2))%nat);
   unfold rep_spec_2, rep_spec_2_hyp.
  (* verif merge *)
  xcf. introv R1 R2 [_ IH]. xmatch; xcleanpat.
  xgo. inverts R2. equates* 1.
  xgo. inverts R1. equates* 1.
  inverts R1. inverts R2. xapp~. xif.
    xapp~.
    applys_to P_x0 nle_to_sle. xapp~. ximpl. equates* 1.
  (* verif link *)
  xcf. intros h1 h2 E1 E2 R1 R2 [IH _] X MX GX. inverts R1. 
  xgo. applys_to MX proj1. eapply (in_empty X). eauto.
  xmatch.
  xgo. inverts H0. forwards~: (>>> min_of_eq MX). constructors*.
  xgo~. forwards~: (>>> min_of_eq MX). constructors*.
Qed.




(*
Lemma testing: 
  forall a A B (P:a->A->Prop) (K:a->A->~~B->Prop) (f:val),
  True ->
  spec_1 (fun x R => forall X, P x X -> K x X R) f.
Admitted.
*)
(*
Lemma min_of_eq : forall X Y E1 E2,
  min_of (\{Y} \u E1 \u E2) X ->
  foreach (is_ge X) E1 ->
  foreach (is_ge X) E2 ->
  X <= Y.
Proof.
  introv [M1 M2] G1 G2. multiset_in M1.
  apply le_refl.
  apply~ M2.
  apply~ M2.
Qed.
*)


(*
Lemma test : (BagEmpty (multiset T)).
typeclass. Qed.
Lemma test2 : (BagCard (multiset T)).
typeclass. Qed.
Lemma test23 : @card_empty (multiset T) _ _ _ = card_empty.
typeclass. Qed.
*)

(*
Definition sum_measure A1 A2 (mu1:A1->nat) (mu2:A2->nat) (p:A1+A2) : nat :=
  match p with 
  | inl x => mu1 x 
  | inr x => mu2 x 
  end.
  (*(sum_measure (fun h1 h2 => 2 * (size h1 + size h2)) (fun h size).*)

Definition size_pair (p:heap*heap) :=
  let (h1,h2) := p in (size h1 + size h2)%nat.
*)
(*
  sets lt: (fun p1 p2 => match p1,p2 with
    | inl x, inr y => size_pair x < size_pair y
    | inr x, inl y => size_pair x <= size_pair y
    | _,_ => False end).
*)

Lemma spec_induction_mut_2_2_2 : 
  forall A11 A12 B1 A21 A22 B2 (lt:binary(A11*A12+A21*A22)),
  forall (Wf: wf lt) f1 f2 (K1:A11->A12->~~B1->Prop) (K2:A21->A22->~~B2->Prop),
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => lt (inl (y1,y2)) (inl (x1,x2)) -> K1 y1 y2 R') f1 ->
    spec_2 (fun y1 y2 R' => lt (inr (y1,y2)) (inl (x1,x2)) -> K2 y1 y2 R') f2 ->
    K1 x1 x2 R) f1 ->
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => lt (inl (y1,y2)) (inr (x1,x2)) -> K1 y1 y2 R') f1 ->
    spec_2 (fun y1 y2 R' => lt (inr (y1,y2)) (inr (x1,x2)) -> K2 y1 y2 R') f2 ->
    K2 x1 x2 R) f2 ->
  spec_2 K1 f1 /\ spec_2 K2 f2.
Admitted.
*)

(*
Definition link_spec := Spec link h1 h2 |R>>
  forall E1 E2,
  inv h1 E1 ->
  inv h2 E2 ->
  forall x ho hs X Eo Es,
  h1 = Node x ho hs ->
  rep x X ->
  inv ho Eo ->
  inv hs Es ->
  foreach (is_ge X) Eo ->
  foreach (is_ge X) Es ->
  foreach (is_ge X) E2 ->
  R (\{X} \u Eo \u Es \u E2 ; heap).
*)
(*
Definition link_spec := RepSpec link (E1;heap) (E2;heap) |R>>
  forall x h1 ho hs X Eo Es,
  rep x X ->
  inv ho Eo ->
  inv hs Es ->
  h1 = Node x ho hs ->
  foreach (is_ge X) Eo ->
  foreach (is_ge X) Es ->
  foreach (is_ge X) E2 ->
  R (\{X} \u Eo \u Es \u E2 ; heap).
*)

(*
Definition is_rep_root X E :=
  match E with
  | Empty => False
  | Node x ho hs => rep x X 
  end.
*)

(* todo: simplify using rep_unique *)



(*-- old

Hint Extern 1 (RegisterSpec link) => Provide link_spec.

Lemma merge_spec : RepTotal merge (E1;heap) (E2;heap) >>
  E1 \u E2 ; heap.
Proof.
  xcf. introv R1 R2. xmatch; xcleanpat.
  xgo. inverts R2. equates* 1.
  xgo. inverts R1. equates* 1.
  inverts R1. inverts R2. xapp~. xif.
  xapp~. ximpl. equates* 1.
  applys_to P_x0 nle_to_sle. xapp~. ximpl. equates* 1.
Qed.

Hint Extern 1 (RegisterSpec merge) => Provide merge_spec.

Lemma link_spec : Spec link h1 h2 |R>>
  forall x ho hs X Eo Es E2,
  h1 = Node x ho hs ->
  rep x X ->
  inv ho Eo ->
  inv hs Es ->
  inv h2 E2 ->
  foreach (is_ge X) Eo ->
  foreach (is_ge X) Es ->
  foreach (is_ge X) E2 ->
  R (\{X} \u Eo \u Es \u E2 ; heap).
Proof.
  xcf. introv Sh1 Rx Ro Rs R2 Lo Ls L2.
  xmatch; inverts H.
  xgo. inverts Ro. constructors*.
  xgo~. constructors*.
Qed.

Hint Extern 1 (RegisterSpec link) => Provide link_spec.

*)


(*
Definition spec_measure_2 
  A1 A2 B (size:A1->A2->nat)
  f (K:A1->A2->~~B->Prop) :=
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => (size y1 y2 < size x1 x2)%nat -> K y1 y2 R') f ->
    K x1 x2 R) f.

Let measure_for2 : forall 
  A11 A12 B1 (size1:A11->A12->nat) f1 (K1:A11->A12->~~B1->Prop) 
  A21 A22 B2 (size2:A21->A22->nat) f2 (K2:A12->A22->~~B2->Prop),
  
(P Q : nat -> Prop),
  (forall n, (forall m, m < n -> P n))

  (forall n, P n /\ Q n).
*)

Lemma merge_spec : RepTotal merge (E1;heap) (E2;heap) >>
  E1 \u E2 ; heap.
Proof.
  xintros. intros h1 h2. intros. sets_eq n: ((size h1 + size h2)%nat).
  gen EQn. gen h1 h2 E1 E2. pattern n.
  match goal with |- ?P _ => sets m_spec: P end.
  applys (>>> proj1 __ (link_spec (S n))). move n after m_spec.
  induction n using peano_induction. rename H into IH. split. 
  (* verif merge *)
  unfolds. clears. introv R1 R2 N. xcf_app. xmatch; xcleanpat.
  xgo. inverts R2. equates* 1.
  xgo. inverts R1. equates* 1.
  inverts R1. inverts R2.
   simpl in N. forwards (_&K): (IH ((n-1)%nat)). math. unfolds in K.
   xapp~. xif.
     xapp~. ximpl. equates* 1.
     applys_to P_x0 nle_to_sle. xapp~. ximpl. equates* 1.
  (* verif link *)
  unfolds. xcf. introv Sh1 Rx Ro Rs R2 Lo Ls L2 N.
  forwards (K&_): (IH ((size h + size a)%nat)). skip. 
   unfolds in K. clears.
  xmatch; inverts H.
  xgo. inverts Ro. constructors*. simpl in K.
  xgo~. xapp. constructors*.
Qed.

(*


Axiom factorize : forall (P1 P2 P3 P4 P5 : nat -> Prop),
  (forall n, P1 n /\ P2 n /\ P3 n /\ P4 n /\ P5 n) ->
  (forall n, P1 (n)) /\ (forall n, P2 (n)) /\ (forall n, P3 (n))
    /\ (forall n, P4 (n))  /\ (forall n, P5 (n)).

Lemma eq_gt_induction_5' : forall (P1 P2 P3 P4 P5 : (nat->Prop) -> Prop),
  eq_gt_implies P1 -> eq_gt_implies P2 -> eq_gt_implies P3 -> 
  eq_gt_implies P4 -> eq_gt_implies P5 ->
  (forall n, P1 (gt n) -> P2 (gt n) -> P3 (gt n) -> P4 (gt n) -> P5 (gt n) -> 
    P1 (eq n) /\ P2 (eq n) /\ P3 (eq n) /\ P4 (eq n) /\ P5 (eq n)) ->
  (forall n, P1 (eq n) /\ P2 (eq n) /\ P3 (eq n) /\ P4 (eq n) /\ P5 (eq n)).
Proof. 
  introv H1 H2 H3 H4 H5 R.
  induction n using peano_induction. apply R;
    match goal with K: eq_gt_implies ?Pi |- ?Pi _ =>
      apply K; intros; forwards*: H; try math end.
Qed. 

Axiom go :forall (P1 P2 P3 P4 P5 : (nat->Prop) -> Prop),
 (forall n, P1 (eq n) /\ P2 (eq n) /\ P3 (eq n) /\ P4 (eq n) /\ P5 (eq n)).
(*
Lemma conj_strengthen_5' : forall (Q1 Q2 Q3 Q4 Q5 P1 P2 P3 P4 P5 : (nat -> Prop) -> Prop),
  (Q1 -> P1) -> (Q2 -> P2) -> (Q3 -> P3) -> (Q4 -> P4) -> (Q5 -> P5) ->
  (Q1 /\ Q2 /\ Q3 /\ Q4 /\ Q5) -> (P1 /\ P2 /\ P3 /\ P4 /\ P5).
Proof. auto*. Qed.
*)

(*
Axiom go' :forall (P1 : (nat->Prop) -> Prop),
 (forall n, P1 (eq n)).

Axiom go'' :forall f n  (P1 P2 : (nat->Prop) -> Prop),
 (f = eq n -> (P1 f /\ P2 f)).
*)
*)

(* todo: move *)




(*
  eapply rep_induction_mut_2_2_2 with 
   (mu1 := fun E1 E2 => (2 * (card E1 + card E2) + 1)%nat)
   (mu2 := fun E1 E2 => (2 * (card E1 + card E2))%nat);
   unfold rep_spec_2, rep_spec_2_hyp.
*)

(*
Hint Extern 1 (@gt nat _ _ _) => check_noevar tt; simpl; rew_card; math.
*)


(*
Ltac all_specs_go :=
  unfolds; first [ xintros; instantiate;  
    [ xcf; auto; 
      try match goal with H: Rep ?a _ |- _ => instantiate (1 := a) end;
      try xisspec | ]
  | xintros ].
*)





(* todo: remove this
Ltac xcurried_core ::=
  let arity := spec_goal_arity tt in
  let lemma := get_curried_prove_x arity in
  eapply lemma; try solve [ xcf; auto; instantiate; 
    try (check_noevar_goal; xisspec) ].
 *)



(* todo: move *)
Lemma Forall2_unique : forall A1 A2 (P:A1->A2->Prop) l L1 L2,
  (forall x X Y, P x X -> P x Y -> X = Y) -> 
  Forall2 P l L1 -> Forall2 P l L2 -> L1 = L2.
Proof.
  induction l; introv H H1 H2; inverts H1; inverts H2; prove_rep.
Qed.

Hint Resolve Forall2_unique : rep.





(* bin:
Lemma inv_nil_change : forall rs rs' Es, 
  inv rs nil Es -> 0 <= rs' -> inv rs' nil Es.
Proof. introv H P. inverts~ H. Qed.


Definition Rank_hd_or r (ts:heap) :=
  match ts with
  | nil => r
  | t::ts => Rank t
  end.

Lemma le_rank_hd_or_elim : forall r ts,
  r <= Rank_hd_or r ts ->
  r <= Rank_hd ts.
Proof. intros. destruct ts.

Lemma inv_smallest : forall rs ts Es,
  inv rs ts Es -> 
  exists rs',
  inv rs' ts Es /\
  rs' <= rs /\
  (ts = nil -> rs' = 0).
Proof.
  introv H. inverts H. exists~ 0.
  exists rs. splits. auto~. auto~. auto_false.
Qed. (* todo: improve autofalse *)


Lemma remove_min_tree_spec : Spec remove_min_tree (ts:heap) |R>>
  forall rs Es, inv rs ts Es -> Es <> \{} -> 
  R (fun o => let (t',ts') := o : tree * heap in
     exists E' Es' X r' rs', 
       btree r' t' E' /\
       inv rs' ts' Es' /\
       Es = E' \u Es' /\
       rep (Root t') X /\
       foreach (is_ge X) Es /\ 
       rs <= rs').
Proof.
(*
  xinduction (@List.length tree). xcf. introv IH RH NE. xmatch.
  xgo. inverts RH. false.
  xgo. inverts RH as Rt R0. inverts R0. 
    lets (X&RX&MX): (root_le_all Rt). subst Es. exists~ ___.
  lets (rs0&E0&Ez&Rt&Rts&K1&K2&EQ): (inv_cons_inv RH). clear RH.
  asserts: (Ez <> \{}). intro_subst_hyp.
    destruct ts. inverts Rts. false. inverts Rts as BT. lets: (btree_not_empty BT).
    skip. (*fsetinv*)
  xapp~. destruct _x1 as [t' ts'].
   destruct P_x1 as (E'&Es'&X&r'&rs'&Rt'&Rts'&EQ'&RX&MX&D).
  xmatch. xapp~. xapp~. cbv beta in *. subst _x3 _x4. 
  lets (Y&RY&MY): (root_le_all Rt). xgo~.
  subst Es. exists~ ___.
  subst Es Ez. applys_to P_x2 nle_to_sle. 
    exists E' (E0 \u Es') __ __ __. splits~. permut_simpl.
*) skip.
Qed.

Hint Extern 1 (RegisterSpec remove_min_tree) => Provide remove_min_tree_spec.

Lemma find_min_spec : RepSpec find_min (E;heap) |R>>
  E <> \{} -> R (min_of E ;; O.t).
Proof.
  xcf. intros e E RepE HasE. simpl in RepE. xgo~.
  destruct P_x0 as (E'&Es'&X&r'&rs'&Rt'&Rts'&EQ'&RX&MX&D).
  ximpl as x Px. subst x. skip: (X \in E). eauto. 
  (* todo: rep_unique to solve this *)
Qed.

Hint Extern 1 (RegisterSpec find_min) => Provide find_min_spec.

Lemma delete_min_spec : RepSpec delete_min (E;heap) |R>>
  E <> \{} -> R (removed_min E ;; heap).
Proof. 
  xcf. introv Rts NE. simpl in Rts. xapp~. xmatch.
  destruct P_x0 as (E'&Es'&X&r'&rs'&Rt'&Rts'&EQ'&RX&MX&D).
  simpl in RX. clear H.
  asserts: (_p0 = r'). inverts~ Rt'. subst.
    forwards~ (Er&I'&EQ'): (>>> inv_rev_children_final x ts1).
  xapp~.  
    sapply~ inv_rank_smaller.
    ximpl as h Ph.
  exists (Er \u Es'). split~. subst E'. exists* X.
Qed.

Hint Extern

*)


(** termination relation *)
(* we could use a size function as well *)

Inductive subtree : set -> set -> Prop :=
  | subtree_left : forall col a x b, subtree a (Node col a x b)
  | subtree_right : forall col a x b, subtree b (Node col a x b).

Hint Constructors subtree.

Lemma subtree_wf : wf subtree.
Proof.
  intros e. induction e;
    constructor; introv H; inversions~ H.
Qed.

Hint Resolve subtree_wf : wf.


Inductive subtree : set -> set -> Prop :=
  | subtree_left : forall a x b, subtree a (Node a x b)
  | subtree_right : forall a x b, subtree b (Node a x b).

Hint Constructors subtree.

Lemma subtree_wf : wf subtree.
Proof.
  intros e. induction e;
    constructor; introv H; inversions~ H.
Qed.

Hint Resolve subtree_wf : wf.

  xinduction (unproj22 elem subtree).  


(* todo: move *)
Lemma Forall2_unique : forall A1 A2 (P:A1->A2->Prop) l L1 L2,
  (forall x X Y, P x X -> P x Y -> X = Y) -> 
  Forall2 P l L1 -> Forall2 P l L2 -> L1 = L2.
Proof.
  induction l; introv H H1 H2; inverts H1; inverts H2; prove_rep.
Qed.

Hint Resolve Forall2_unique : rep.

(*todo:move
Definition rep_from_eq : forall A, Rep A A.
Proof. intros. apply (Build_Rep eq). congruence. Defined.
*)

(*
Lemma rep_null : forall `{Rep a A},
  rep Null (@nil A).
Proof. exists~ __. Qed.
Hint Resolve @rep_null.
*)


     (* todo : or patterns 
        let balance = function
     | (Black, Node (Red, Node (Red, a, x, b), y, c), z, d) ->
       Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
     | (Black, Node (Red, a, x, Node (Red, b, y, c)), z, d) ->
       Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
     | (Black, a, x, Node (Red, Node (Red, b, y, c), z, d)) ->
       Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
     | (Black, a, x, Node (Red, b, y, Node (Red, c, z, d))) ->
       Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
     | (c,a,x,y) -> Node (c,a,x,y)

*)




(*

Lemma inv_weaken : forall p ts L,
  inv false p ts L -> inv true p ts L.
Proof. introv M. inverts M; constructors~. Qed.

Hint Resolve @inv_weaken.

(* todo: use next one *)
Lemma inv_strengthen : forall p ts L T,
  inv true p ts (T++L) -> T <> nil -> inv false p ts (T++L).
Proof.
  introv M. gen_eq L':(T++L). gen T L. induction M; intros; subst.
  false H0. destruct~ (nil_eq_app_inv H).
  constructors~.
  constructors~.
Qed.

Lemma inv_strengthen' : forall p ts L,
  inv true p ts L -> L <> nil -> inv false p ts L.
Proof.
  introv M. induction M; intros; subst; tryfalse; auto~.
Qed.


Lemma inv_strengthen'' : forall p ts L,
  inv true p ts L -> ts <> nil -> inv false p ts L.
Proof.
  introv M. induction M; intros; subst; tryfalse; auto~.
Qed.



Hint Resolve @btree_not_empty.
(*Hint Resolve @inv_strengthen.*)

*)
Hint Extern 1 (@rep (rlist _) _ _ _ _) => simpl.



(*
Lemma inv_size_pos : forall p ts L,
  inv p ts L -> p >= 0.
Proof. introv Rts. induction Rts; unfolds eq'. auto. math.  Qed.
Hint Resolve btree_size_pos.
*)

(* needed?
Lemma btree_zero_inv : forall t L,
  btree 0 t L -> exists x, t = Leaf x.
Proof. 
  introv H. inverts H. eauto.
  lets: (btree_size_pos H0). math.
Qed.
*)

  (* applys* (>>> inv_node (\{Y0} \u A0 \u B0) Y (\{X} \u B \u E2)).*)
(*  applys* (>>> inv_node (\{Y} \u A \u A0) Y0 (\{X} \u B0 \u E2)). *)



    xgo~ '_x4 XstopAfter, '_x3 XstopAfter.
    xapp~. destruct~ col; destruct (node_color a); tryifalse; auto.
    ximpl as e. simpl. destruct col. subst. equates* 1.

    forwards~ M: (>>> inv_weaken' (match col with Black => false | Red => true end)).
      intro; destruct col; destruct (node_color a); destruct Col; tryfalse; auto.
     clear P_x4. xapp~. destruct~ col.
     ximpl as e. simpl. destruct col; subst; equates* 1.
    forwards~ M: (>>> inv_weaken' (match col with Black => false | Red => true end)).
      intro; destruct col; destruct (node_color b); destruct Col; tryfalse; auto.
     clear P_x3. xapp~. destruct~ col.
     ximpl as e. simpl. destruct col; subst; equates* 1.




(*
Definition head_spec := proj53 all_specs.
Definition tail_spec := proj54 all_specs.
Definition snoc_spec := proj55 all_specs.
*)

(*bin

Definition snoc_specs `{Rep a A} :=
  Spec snoc (q:queue a) (x:a) |R>>
     forall X Q, rep x X -> rep q Q ->
     R (fun q' => rep q' (Q&X)).



    (* case empty *)
    clear PN3 IHsnoc. subst m Qm. inverts H11. 
    rew_concat in *. rew_length in H18. 
    apply app_spec_1. apply~ checkf_cf. xisspec.
    intros b B. subst b. xmatch. xmatch.
      xret. inverts H9. inverts P3.
      specializes IHhead (>>> (list a) (rev Qr :: nil)). xapp~. clear IHhead.
      xlet (= Empty (A:=list a)). apply app_spec_1. apply~ tail_cf. xisspec.
       intros b B. subst b. rewrite~ PE3. xmatch.
      apply app_spec_1. apply~ checkq_cf. xisspec.
       intros b B. subst b. xmatch. xif; try math.
      apply app_spec_1. apply~ checkf_cf. xisspec.
       intros b B. subst b q. xmatch. xmatch. xret~. false~ C3.
      subst _x0. xret. xrep in P_x2. inverts H9. subst Q.
       rew_list. rew_length in *. inverts PX as M. inverts M.
         constructors~. rew_length~. rew_list~. simpl in RX.
         intro_subst_hyp. inverts RX as M. applys_to M nil_eq_rev_inv.
          subst Qr. rew_length in *. math.
      xret. constructors~. rew_list~. rew_list~. intro_subst_hyp. false~ C1.
       apply~ doubling_cons. rew_length~.
    (* case not empty *)
    clear PE3 IHhead. 
    xapp. constructors~. subst Qm. rew_list~. subst Q Qm. rew_list~.
    apply~ doubling_last. subst Qm. rew_length~.
    simpl. rewrite~ PN3.

*)

(* bin: check needed

Lemma decrease_r : forall A (Q Qf Qm Qr : list A) Qms,
  Q = Qf ++ Qm ++ rev Qr ->
  0 < length Qr -> 
  Qm = concat Qms ->
  doubling true 1 Qms ->
  length Qms < length Q.
Proof.
  introv E L Em Dm. destruct Qr. gen L. rew_list~. 
  forwards: (concat_doubling_length Dm).
  subst Q Qm. rew_length~.
Qed.

Lemma decrease_f : forall `{Rep a A} f (Q Qf Qm Qr : list A) Qms,
  Q = Qf ++ Qm ++ rev Qr ->
  f <> nil -> rep f Qf ->
  Qm = concat Qms ->
  doubling true 1 Qms ->
  length Qms < length Q.
Proof.
  introv E L R Em Dm. destruct f. false. inverts R.
  forwards: (concat_doubling_length Dm).
  subst Q Qm. rew_length~.
Qed.
 *)


(*bin
Fixpoint depth a (q:queue a) : nat :=
  match q with
  | Empty => 0%nat

  

Ltac xapp_compact KR args :=
  let args := ltac_args args in
  match args with (boxer ?mode)::?vs => 
  let args := constr:((boxer mode)::(boxer KR)::vs) in
  constr:(args)
  end.

Ltac xapp_inst args solver :=
  let R := fresh "R" in let LR := fresh "L" R in 
  let KR := fresh "K" R in let IR := fresh "I" R in
  intros R LR KR;
  let H := xapp_compact KR args in
  forwards IR: H; solver tt; try sapply IR. 



  eapply local_wframe.
     [ try xlocal
     | eapply K; [ apply H | idtac ] 
     | hsimpl 
     | xok ].
  xapp_inst (>>>) ltac:(fun _ => eauto).
  
  eapply local_wframe; 
     [ xlocal
     | eapply K; [ apply H | idtac ] 
     | hsimpl 
     | xok ].
  xapp_inst (>>>) ltac:(fun _ => eauto).
  intros R LR KR.
   forwards IR: (>>> KR); eauto; try sapply IR. hsimpl.






xapp_manual.

Qed.
 lenfm f m lenr r => (1 + depth m)%nat
  end.
*)


(** Full garbage collection on postcondition from [local] 

Lemma local_gc_post_all : forall B Q (F:~~B) H HG (P:B->Prop),
  is_local F -> 
  Q ===> \[P] \*+ HG ->
  F H Q ->
  F H (\[P]).
Proof. intros. apply* local_gc_post. Qed.

Tactic Notation "xgc_post_all" := 
  eapply local_gc_pre with (H' := H);
    [ try xlocal
    | hsimpl
    | ].

*)



Lemma xret_lemma : forall B (v:B) H (Q:B->hprop),
  (\= v \*+ H) ===> Q -> 
  local (fun H Q => H heap_empty /\ Q v heap_empty) H Q.
Proof.  
  introv W. applys local_wframe B [] H (\= v). (* todo: instantiate *)
  simpls. auto.
  apply local_erase. split. reflexivity. hnfs~. hsimpl. auto.
Qed.


   




  (* détails de xapp
  xapp_manual. applys KR. hsimpl.

  xfind ml_ref; let H := fresh in intro H.
  lets K: spec_elim_1_1.
  xapp_manual as.
  xapp_inst (>>>) ltac:(fun _ => eauto).
  hsimpl.
  *)





(* bin *)
Lemma hsimpl_prop_1 : forall (P1:Prop),
  P1 -> [] ==> [P1].
Proof. introv H K. (*surprenant: destruct K.*)
  skip. (* todo *)
Qed.




Lemma local_wframe' : forall B H1 H2 Q1 (F:~~B) H Q,
  is_local F -> 
  H ==> H1 \* H2 -> 
  F H1 Q1 -> 
  Q1 \*+ H2 ===> Q ->
  F H Q.
Proof. intros. apply* local_wframe. Qed.

Lemma local_gc_post' : forall H' B (F:~~B) H Q,
  is_local F -> 
  F H (Q \*+ H') ->
  F H Q.
Proof. intros. apply* local_gc_post. Qed.



Lemma hclean_exists : forall B (F:~~B) H1 H2 A (J:A->hprop) Q,
  is_local F -> 
  (forall x, F ((H1 \* (J x)) \* H2) Q) ->
   F (H1 \* (heap_is_pack J \* H2)) Q.
Proof. 
  intros. rewrite star_comm_assoc. apply~ local_intro_exists.
  intros. rewrite star_comm_assoc. rewrite~ star_assoc. 
Qed. 



Lemma post_le_unit : forall H H' : hprop,
  H ==> H' -> (#H) ===> (#H').
Proof. intros_all~. Qed.


Lemma xfor_frame__ : forall I H' a b H Q (Fof:int->~~unit),
  (forall i, is_local (Fof i)) ->
  (a > (b)%Z -> H ==> (Q tt)) ->
  ((a <= (b)%Z) -> 
      (H ==> I a \* H') 
   /\ (forall i, a <= i /\ i <= (b)%Z -> (Fof i) (I i) (# I(i+1))) 
   /\ (I ((b)%Z+1) \* H' ==> Q tt)) ->
  local (fun H Q => (a > (b)%Z -> H ==> (Q tt)) /\ (a <= (b)%Z -> exists I,
     H ==> I a /\ (forall i, a <= i /\ i <= (b)%Z -> (Fof i) (I i) (# I(i+1))) /\ (I ((b)%Z+1) ==> Q tt))) H Q.
Proof.
  introv L M1 M2. apply local_erase. split. auto.
  introv M3. intuit (M2 M3). exists (I \*+ H'). splits*.
  intros i Hi. specializes H1 Hi. apply* local_wframe.
Qed.

Lemma xfor_frame_le__ : forall I H' a b H Q (Fof:int->~~unit),
  (a <= (b)%Z) -> 
  (H ==> I a \* H') ->
  (forall i, a <= i /\ i <= (b)%Z -> (Fof i) (I i) (# I(i+1))) ->
  (I ((b)%Z+1) \* H' ==> Q tt) ->
  local (fun H Q => (a > (b)%Z -> H ==> (Q tt)) /\ (a <= (b)%Z -> exists I,
     H ==> I a /\ (forall i, a <= i /\ i <= (b)%Z -> (Fof i) (I i) (# I(i+1))) /\ (I ((b)%Z+1) ==> Q tt))) H Q.
Proof.
  introv M1 M2 M3 M4. apply~ (>>> local_wframe unit __ H' (fun _:unit => I (b+1))).
  apply local_erase. split. intros. false. math.
  intros. exists* I. intros t. destruct t. auto.
Qed.



(*
Lemma temp2 : forall (H:hprop),
  H ==> (fun _ => H) tt.
Proof. auto. Qed.
*)



Parameter ml_ref_spec : forall a,
  Specs ml_ref (v:a) >> [] (~> RefOn v).

Parameter ml_get_spec : forall a,
  Spec ml_get (l:loc) |R>> 
    forall v:a, read R (l ~> RefOn v) (\=v).

Parameter ml_set_spec : forall a,
  Spec ml_set (l:loc) (v:a) |R>> 
    forall v':a, R (l ~> RefOn v') (# l ~> RefOn v).
 
   
 (*| _ =>  
          match TX with 
          | TX => fail 1
          | _ => let K := fresh "TEMP" in sets_eq K: (X : ltac_tag_subst hprop)
          end*)


Ltac protect_evars_in H ::=
   match H with context [ ?X ] =>
     let go tt := 
       match X with
       | _ \* _ => fail 1
       | X => fail 1 
       | ?x ~> ?R => 
           match x with x =>
           (*
          let doit m :=
             let Tm := type of m in
             let K := fresh "TEMP" in sets_eq K: (m : ltac_tag_subst Tm);
             change K with (ltac_tagged K) in
          match x with 
          | x => match R with R  doit R
          | ltac_tagged _ => doit R
          | _ => doit x
          end*)

       | _ ~>  => fail 1
       | ?R ~> _ => let TR := type of R in
           let K := fresh "TEMP" in sets_eq K: (R : ltac_tag_subst TR);
           change K with (ltac_tagged K)
       | _ ~> ?R => let TR := type of R in
           let K := fresh "TEMP" in sets_eq K: (R : ltac_tag_subst TR);
           change K with (ltac_tagged K)
       | _ => let K := fresh "TEMP" in sets_eq K: (X : ltac_tag_subst hprop)
       end in
     match type of X with 
     | hprop => go tt
     | heap -> Prop => go tt
     end
  end.

Ltac protect_evars tt ::=
  do 5 try match goal with |- ?H1 ==> ?H2 =>
     first [ protect_evars_in H1 | protect_evars_in H2 ]; instantiate
  end; unfold ltac_tagged. 

Ltac protect_evars_in H ::=
   match H with context [ ?X ] =>
     let go tt := 
       match X with
       | _ \* _ => fail 1
       | X => fail 1 
       | ?x ~> ?R => 
           match x with
           | x => idtac             
           | _ => fail 20 "Uninstantiated argument at left of ~>"
           end;
           let TR := type of R in
           let K := fresh "TEMP" in 
           sets_eq K: (R : ltac_tag_subst TR)
       | _ => let K := fresh "TEMP" in
              sets_eq K: (X : ltac_tag_subst hprop)
       end in
     match type of X with 
     | hprop => go tt
     | heap -> Prop => go tt
     end
  end.




Lemma esplit_boolof : forall (b:bool) (H:hprop) (P:(bool->hprop)->Prop),
  P (\= b \*+ H) -> ex P.
Proof. intros. exists (\= b \*+ H). applys_eq H0 1. extens~. Qed.

Ltac xwhile_body_manual :=
  let x := fresh "X" in intros x; xextract;
  pose ltac_mark; intros; apply local_erase; gen_until_mark.

Ltac xwhile_body_handle :=
  intros; eapply esplit_boolof; splits.

Ltac xwhile_core I R X := 
  first [ eapply (@xwhile_frame _ I R)
        | eapply (@xwhile_frame _ I (measure R))];
  [ xlocal
  | xlocal
  | try prove_wf
  | exists X; instantiate; hsimpl 
  | try xwhile_body_manual (* ; try xwhile_body_handle*)
  | hsimpl ].

Ltac xwhile_manual_core I R := 
  first [ eapply (@xwhile_frame _ I R)
        | eapply (@xwhile_frame _ I (measure R))];
  [ xlocal
  | xlocal
  | idtac
  | idtac
  | try xwhile_body_manual
  | idtac ].


Tactic Notation "xwhile" constr(I) constr(R) constr(X) := 
  xwhile_core I R X.
Tactic Notation "xwhile" constr(I) constr(R) := 
  xwhile I R __.
Tactic Notation "xwhile_manual" constr(I) constr(R) := 
  xwhile_manual_core I R.


Ltac xfor_frame_side tt := 
  let H' := fresh in let PH' := fresh in
  let i := fresh in let Pi := fresh in
  intros H' PH' i Pi; eapply local_frame; 
   [try xlocal | apply PH'; apply Pi ].


Ltac xfor_core I := 
  let Hi := fresh "Hfor" in
  eapply (@xfor_frame I); 
  [ try solve [ xfor_frame_side tt ]
  | intros Hfor; try solve [ false; math ]
  | intros Hfor; splits (3%nat); 
     [ hsimpl 
     | xfor_bounds_intro tt
     | hsimpl ] 
  ].

Ltac xfor_le_core I :=
  eapply (@xfor_frame_le I);
  [ try math
  | xfor_bounds_intro tt
  | hsimpl ].

Tactic Notation "xfor" constr(I) := 
  xfor_core I.

Tactic Notation "xfor_le" constr(I) := 
  xfor_le_core I.




Notation "'Hexists' x1 x2 , H" := (Hexists x1, Hexists x2, H)
  (at level 39, x1 ident, x2 ident, H at level 50) : heap_scope.
Notation "'Hexists' x1 x2 x3 , H" := (Hexists x1, Hexists x2, Hexists x3, H)
  (at level 39, x1 ident, x2 ident, x3 ident, H at level 50) : heap_scope.
Notation "'Hexists' x1 x2 x3 , H" := (Hexists x1, Hexists x2, Hexists x3, Hexists x4, H)
  (at level 39, x1 ident, x2 ident, x3 ident, x4 ident, H at level 50) : heap_scope.

Notation "'keep' R H Q" :=
  (R H (Q \*+ H)) (at level 25, R at level 0, H at level 0, Q at level 0).



(*
Fixpoint List A a (T:A->a->hprop) (L:list A) (l:loc) : hprop :=
  match L with
  | nil => [True]
  | X::L' => Hexists x l', T X x \* l ~> RefOn (x,l') \* List T L' l'
  end.
*)

(* 
Ltac hchange_core H :=
  first [ apply (@hchange_lemma H)
        | applys hchange_lemma H ]; 
  hsimpl.



Ltac xchange_lemma_core L :=
  eapply xchange_lemma; 
    [ try apply local_is_local
    | applys L
    | hsimpl
    | ].


(*
Definition pred_le' := pred_le.
Lemma pred_le_change : pred_le = pred_le'.
Proof. auto. Qed.
Opaque pred_le'.

Ltac xchange_lemma_core L ::=
  let K := fresh "TEMP" in
  let K' := fresh "TEMP" in
  lets K: L; 
  rewrite pred_le_change in K;
  forwards K': K;
  rewrite <- pred_le_change in K;
  clear K;
  eapply xchange_lemma; 
    [ clear K'; try apply local_is_local
    | apply K'
    | clear K'; instantiate; try hsimpl
    | clear K' ].
*)





Axiom spec_induction_2_noarg : 
  forall A1 A2 B A0 (lt:binary A0),
  forall (Wf: wf lt) f (L:A0->A1->A2->~~B->Prop),
  (forall y, is_spec_2 (L y)) ->
  spec_2 (fun x1 x2 R => forall x0,
    spec_2 (fun y1 y2 R' => forall y0, 
      lt y0 x0 -> L y0 y1 y2 R') f ->
    L x0 x1 x2 R) f ->
  spec_2 (fun x1 x2 R => forall x0, L x0 x1 x2 R) f.

Axiom spec_induction_3_noarg : 
  forall A1 A2 A3 B A0 (lt:binary A0) (Wf: wf lt) f 
         (L:A0->A1->A2->A3->~~B->Prop),
  (forall y, is_spec_3 (L y)) ->
  spec_3 (fun x1 x2 x3 R => forall x0,
    spec_3 (fun y1 y2 y3 R' => forall y0,
      lt y0 x0 -> L y0 y1 y2 y3 R') f ->
    L x0 x1 x2 x3 R) f ->
  spec_3 (fun x1 x2 x3 R => forall x0, L x0 x1 x2 x3 R) f.

Axiom spec_induction_4_noarg : 
  forall A1 A2 A3 A4 B A0 (lt:binary A0) (Wf: wf lt) f 
         (L:A0->A1->A2->A3->A4->~~B->Prop),
  (forall y, is_spec_4 (L y)) ->
  spec_4 (fun x1 x2 x3 x4 R => forall x0,
    spec_4 (fun y1 y2 y3 y4 R' => forall y0,
       lt y0 x0 -> L y0 y1 y2 y3 y4 R') f ->
    L x0 x1 x2 x3 x4 R) f ->
  spec_4 (fun x1 x2 x3 x4 R => forall x0, L x0 x1 x2 x3 x4 R) f.







(*test*)

Definition pureapp' A B (F:val) (V:A) (P:B->Prop) :=
  app_1 F V [] \[P].

Definition spec_2' A1 A2 B (K: A1 -> A2 -> ~~B -> Prop) f :=
  is_spec_2 K /\ forall x1, pureapp' f x1 (spec_1 (K x1)).

Definition curried_2' (A1 A2 B:Type) f := 
  spec_2' (fun (x1:A1) (x2:A2) (R:~~B) => True) f.


Lemma spec_intro_2 : forall A1 A2 B f (K:A1->A2->~~B->Prop),
  is_spec_2 K ->
  curried_2' A1 A2 B f ->
  (forall x1 x2, K x1 x2 (app_2 f x1 x2)) ->
  spec_2' K f.
Proof.
  introv I C HK. split~.
  intros x1.
  lets U: (proj2 C x1). unfolds pureapp'.
  applys local_weaken U. skip. skip. intros g.
  hextract. hsimpl.
  split. skip. intros x2. applys I. apply HK.
  intros H Q Ap.
  apply local_name_heap. skip.
  intros h Hh. specializes Ap Hh.
  destruct Ap as (H1&H2&Q1&H'&?&(Q'&Ap1&Ap2)&Po).
  hnf in Ap1.
  destruct H3 as (h1&h2&?&?&H5&H6).
  specializes Ap1 h1 h2 __ __. auto. auto.
  destruct Ap1 as (v'&h'&g'&D'&Re&Ev).

  hnf. intros h_ i D'' E. hnf in E. subst h_.
  exists___. splits 3%nat. skip. skip. 

  applys local_wgframe Po. skip. apply Ap2.
  intros h'. intro_subst.
  hnf in U.
  specializes 

  intros h i Dhi Hh.
  specializes Ap Hh.
  destruct Ap as (H1&H2&Q1&H'&?&(Q'&Ap1&Ap2)&Po).
  destruct H3 as (h1&h2&?&?&H5&H6).
  specializes Ap1 h1 (h2 \+ i) __ __. skip. auto. (* todo*)
  destruct Ap1 as (v'&h'&g'&D'&Re&Ev).
  exists v'. (h' \+ h2).
    

 hnf.

 destruct (pureapp_witness (proj2 C x1)) as [g [_ Hg]].
  apply* pureapp_abstract. split~. intros x2. eapply I.
  apply HK.
  intros H Q M.
  rewrite app_local_1. introv Hh.
  destruct (M _ Hh) as (H1&H2&Q1&H'&?&(Q'&Ap1&Ap2)&Po).
  specializes Ap2 g.
  destruct H0 as (h1&h2&?&?&?&?).
  forwards* (H''&Ro): (>>> (@pureapp_and_app_1) f x1).
  exists (Q' g \* H'') H2 __ (H' \* H''). splits.
    subst. exists___*.
    apply* local_wframe.
    intros r. specializes Po r. hsimpl. auto.
Admitted. (* existentials *)




Lemma unfocus_mnil : forall (l:loc) A,
  l ~> @Mlist A nil ==> [l = null].
Proof. intros. simpl. hdata_simpl. hsimpl~. Qed.




(*
Ltac hclean_on contH contQ :=
  match goal with
  | |- _ ?H ?Q => contH H; contQ Q
  | |- _ _ ?H ?Q => contH H; contQ Q
  | |- _ _ _ ?H ?Q => contH H; contQ Q
  | |- _ _ _ _ ?H ?Q => contH H; contQ Q
  end.
*)



(* deprecated 

Ltac protect_evars_in H :=
   match H with context [ ?X ] => 
     let go tt := 
       match X with
       | _ \* _ => fail 1
       | _ ~> _ => fail 1
       | X => fail 1 
       | _ => let K := fresh "TEMP" in sets_eq K: (X : ltac_tag_subst hprop)
       end in
     match type of X with 
     | hprop => go tt
     | heap -> Prop => go tt
     end
   end.

Ltac protect_evars_in H ::=
   match H with context [ ?X ] =>
     let go tt := 
       match X with
       | _ \* _ => fail 1
       | X => fail 1 
       | ?x ~> ?R => 
           match x with
           | x => idtac             
           | _ => fail 20 "Uninstantiated argument at left of ~>"
           end;
           let TR := type of R in
           let K := fresh "TEMP" in 
           sets_eq K: (R : ltac_tag_subst TR)
       | _ => let K := fresh "TEMP" in
              sets_eq K: (X : ltac_tag_subst hprop)
       end in
     match type of X with 
     | hprop => go tt
     | heap -> Prop => go tt
     end
  end.

*)

(*
Ltac hsimpl_assoc_rhs tt :=
  let M := fresh "TEMP" in
  match goal with |- ?H ==> ?H' =>
    sets M: H'; autorewrite with hsimpl_assoc; subst M
  end.
hsimpl_assoc_rhs tt.*)


(*--deprecated
Ltac hsimpl_find_data H HL :=
  match H with hdata _ ?l =>
  match HL with
  | hdata _ l \* _ => apply hsimpl_cancel_1
  | _ \* hdata _ l \* _ => apply hsimpl_cancel_2
  | _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_3
  | _ \* _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_4
  | _ \* _ \* _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_5
  | _ \* _ \* _ \* _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_6
  end end.
*)


(* todo: bin
Lemma heap_disjoint_union_r : forall h1 h2 h3,
  heap_disjoint h1 h2 -> heap_disjoint h1 h3 ->
  heap_disjoint h1 (heap_union h2 h3).
Proof.
Qed.

Lemma heap_disjoint_union_inv_r : forall h1 h2 h3,
  heap_disjoint h1 (heap_union h2 h3) ->
  heap_disjoint h1 h2 /\ heap_disjoint h1 h3.
Proof.
  intros [f1 F1] [f2 F2] [f3 F3] M.
  unfolds heap_disjoint, heap_union. simpls.
  unfolds pfun_disjoint, pfun_union. 
  split; intros x; specializes M x; 
   destruct (f2 x); intuition. false.
Qed.

Lemma heap_disjoint_union_inv_l : forall h1 h2 h3,
  heap_disjoint (heap_union h2 h3) h1 ->
  heap_disjoint h1 h2 /\ heap_disjoint h1 h3.
Proof. introv H. apply~ heap_disjoint_union_inv_r. Qed.
*)



(** Star with post-conditions (predicates of type [B->hprop]) 

Definition starpost B (Q:B->hprop) (H:hprop) : B->hprop :=
  fun x => heap_is_star (Q x) H.
*)
(*bin
Notation "\= V" := (\[ = V])
  (at level 40) : heap_scope.
*)

(*
Notation "l '~~~>' v" := (heap_is_single l v)
  (at level 35, no associativity) : heap_scope.
*)




Definition heaps_union (hs : list heap) : heap :=
  LibList.fold_right heap_union heap_empty hs.

(** Heap well-defineteness *)

Definition heap_defined (h : heap) : Prop :=
  h <> None.
 
(** Heap disjointness *)

Definition heaps_disjoint (hs : list heap) : Prop :=
  heap_defined (heaps_union hs).

Notation "\# h1 h2 h3" := (heaps_disjoint (h3::h2::h1::nil))
  (at level 40, h1 at level 0, h2 at level 0, h3 at level 0, no associativity).
*)
(*
Lemma test : forall h1 h2 h3, (\# h1 h2) = (\# h1 h2) /\ (\# h1 h2 h3) = (\# h1 h2 h3).
*)


(*
Lemma app_intro_prop_1 : forall (U:Prop) A B (F:val) (V:A) (H:hprop) (Q:B->hprop),
  (H ==> [U]) -> (U -> app_1 F V H Q) -> app_1 F V H Q.
Proof.
  introv W M. eapply local_intro_prop.
Qed.
*)



Axiom pureapp_and_app' : forall A B (F:val) (V:A) (V':B) (H:hprop) (Q:B->hprop) h,
  pureapp F V (= V') -> app_1 F V H Q -> H h -> exists H', (Q V' \* H') h. 



(* -- deprecated
Lemma xfor_frame : forall I H' a b H Q (F:~~unit),
  is_local F ->
  (a > (b)%Z -> H ==> (Q tt)) ->
  ((a <= (b)%Z) -> 
      (H ==> I a \* H') 
   /\ (forall i, a <= i /\ i <= (b)%Z -> F (I i) (# I(i+1))) 
   /\ (I ((b)%Z+1) \* H' ==> Q tt)) ->
  local (fun H Q => (a > (b)%Z -> H ==> (Q tt)) /\ (a <= (b)%Z -> exists I,
     H ==> I a /\ (forall i, a <= i /\ i <= (b)%Z -> F (I i) (# I(i+1))) /\ (I ((b)%Z+1) ==> Q tt))) H Q.
Proof.
  introv L M1 M2. apply local_erase. split. auto.
  introv M3. intuit (M2 M3). exists (I \*+ H'). splits*.
  intros i Hi. specializes H1 Hi. apply* local_wframe.
Qed.

Lemma xfor_frame_le : forall I H' a b H Q (F:~~unit),
  (a <= (b)%Z) -> 
  (H ==> I a \* H') ->
  (forall i, a <= i /\ i <= (b)%Z -> F (I i) (# I(i+1))) ->
  (I ((b)%Z+1) \* H' ==> Q tt) ->
  local (fun H Q => (a > (b)%Z -> H ==> (Q tt)) /\ (a <= (b)%Z -> exists I,
     H ==> I a /\ (forall i, a <= i /\ i <= (b)%Z -> F (I i) (# I(i+1))) /\ (I ((b)%Z+1) ==> Q tt))) H Q.
Proof.
  introv M1 M2 M3 M4. apply~ (>>> local_wframe unit __ H' (fun _:unit => I (b+1))).
  apply local_erase. split. intros. false. math.
  intros. exists* I. intros t. destruct t. auto.
Qed.

Lemma xwhile_frame : forall A I (R:binary A) H' H Q (F1:~~bool) (F2:~~unit),
  is_local F1 -> 
  is_local F2 -> 
  wf R ->
  (exists x, H ==> I x \* H') ->
  (forall x, exists Q', 
            F1 (I x) Q'
         /\ F2 (Q' true) (# Hexists y, (I y) \* [R y x])
         /\ (Q' false \* H' ==> Q tt )) ->
  local (fun H Q => exists A, exists I, exists R:binary A,
       wf R 
     /\ (exists x, H ==> I x)
     /\ (forall x, exists Q', 
            F1 (I x) Q'
         /\ F2 (Q' true) (# Hexists y, (I y) \* [R y x])
         /\ (Q' false ==> Q tt))) H Q.
Proof.
  introv L1 L2 M1 M2 M3. apply local_erase.
  exists A (I \*+ H') R. splits*.
  intros x. destruct (M3 x) as (Q'&H1&H2&H3).
  exists (Q' \*+ H'). splits.
  apply* local_wframe.
  apply* local_wframe. skip. (*todo: hsimpl_back *)
  auto.
Qed.

Ltac xfor_core I := 
  let Hi := fresh "Hfor" in
  eapply (@xfor_frame I); 
  [ xlocal
  | intros Hfor; try solve [ false; math ]
  | intros Hfor; splits (3%nat); 
     [ hsimpl 
     | xfor_bounds_intro tt
     | hsimpl ] 
  ].

Ltac xfor_le_core I :=
  eapply (@xfor_frame_le I);
  [ try math
  | hsimpl
  | xfor_bounds_intro tt
  | hsimpl ].


Ltac xwhile_core I R X := 
  first [ eapply (@xwhile_frame _ I R)
        | eapply (@xwhile_frame _ I (measure R))];
  [ xlocal
  | xlocal
  | try prove_wf
  | exists X; instantiate; hsimpl 
  | idtac ].

Ltac xwhile_manual_core I R := 
  first [ eapply (@xwhile_frame _ I R)
        | eapply (@xwhile_frame _ I (measure R))];
  [ xlocal
  | xlocal
  | idtac
  | idtac
  | idtac ].
*)



Axiom hextract_prop : forall H H' (P:Prop),
  (P -> H ==> H') -> ([P] \* H) ==> H'.



(*

  introv S. intros. destruct (pureapp_witness ((proj22 S) x1)) as [g [Pg Hg]].
  lets: ((proj2 Pg) x2). apply* (proj1 S). intros H' Q Ap1.
  exists (fun g' => [g'=g] \* H'). split. apply* pureapp_app_1. 
   intros g'.
   apply (@app_pre_1 (g'=g)).
   skip. (* tactic for heaps: [g' = g] ** H' ==> [g' = g] *)
   intro_subst.
   eapply local_weaken with (H':=H'); eauto. 
    skip. (* tactics for heaps: [g = g] ** H' ==> H' *)
*)




(*
intros. destruct H as [I Ap1].
specializes Ap1 x1.
eapply app_intro_1_2.
apply~ pureapp_app_1. eauto.
intros g.
rew_heap.
apply~ app_pre_1.
intros M.
eapply local_weaken with (H':=[]). auto.
forwards: (spec_elim_2_1 M). eapply H.
skip. (* todo: heaps ==> *)
auto.
*)



(*

Definition with_pre (H:hprop) B (R:~~B) :=
  fun (H':hprop) (Q:B->hprop) => H = H' /\ R H Q.

Lemma spec_induction_1 : 
  forall A1 B A' (I:A'->hprop),
  forall (lt:binary (A1*A')) (Wf: wf lt) f (K:A1->~~B->Prop),
  spec_1 (fun x R => forall y,
    spec_1 (fun x' R' => forall y', lt (x',y') (x,y) -> K x' (with_pre (I y') R')) f ->
    K x (with_pre (I y) R)) f ->
  spec_1 K f.
Proof.
  introv W H.
  cuts Hyp: (forall x, is_spec_0 (K x) /\ K x (app_1 f x)).
    apply spec_intro_1. 
      intros x. apply (proj1 (Hyp x)).
      apply* spec_curried_1.
      intros x. destruct~ (Hyp x).
  cuts Hyp': (forall x y, is_spec_0 (K x) /\ K x (with_pre (I y) (app_1 f x))).
    
  intros x. pattern x.   induction_wf IH: W x.
  lets C: (spec_curried_1 H). 
  lets I: (spec_is_spec_1 H x).
  lets S: (spec_elim_1 H x). clear H. 
  asserts M: (spec_1 (fun x' R' => lt x' x -> K x' R') f). split.
    intros x'. introv HK HP Lt. applys~ (proj1 (IH _ Lt)).
    intros x' Lt. apply (proj2 (IH _ Lt)).
  split.
    introv HK HP. applys~ (I P P').
    apply~ S.
Qed.




Definition post_for (h:heap) B (R:~~B) :=
  fun (H:hprop) (Q:B->hprop) => H h -> R H Q.

Lemma spec_induction_1 : 
  forall A1 B (lt:binary (heap*A1)),
  forall (Wf: wf lt) f (K:A1->~~B->Prop),
  spec_1 (fun x R => forall h,
    spec_1 (fun x' R' => forall h', lt (h',x') (h,x) -> K x' (post_for h' R')) f ->
    K x (post_for h R)) f ->
  spec_1 K f.
Admitted.

Proof.
  introv W H.
  cuts I: (forall x, weakenable (K x) /\ K x (app_1 f x)).
    apply spec_intro_1. 
      intros x. apply (proj1 (I x)).
      apply* spec_curried_1.
      intros x. destruct~ (I x).
  intros x. pattern x. induction_wf IH: W x.
  lets C: (spec_curried_1 H). 
  lets I: (spec_is_spec_1 H x).
  lets S: (spec_elim_1 H x). clear H. 
  asserts M: (spec_1 (fun x' R' => lt x' x -> K x' R') f). split.
    intros x'. introv HK HP Lt. applys~ (proj1 (IH _ Lt)).
    intros x' Lt. apply (proj2 (IH _ Lt)).
  split.
    introv HK HP. applys~ (I P P').
    apply~ S.
Qed.

Lemma spec_induction_2 : 
  forall A1 A2 B (lt:(A1*A2)->(A1*A2)->Prop),
  forall (Wf: wf lt) f (K:A1->A2->~~B->Prop),
  spec_2 (fun x1 x2 R => 
    spec_2 (fun y1 y2 R' => lt (y1,y2) (x1,x2) -> K y1 y2 R') f ->
    K x1 x2 R) f ->
  spec_2 K f.
Proof.
  introv W H.
  cuts I: (forall p : A1*A2, let (x,y) := p in
           weakenable (K x y) /\ K x y (app_2 f x y)).
    apply spec_intro_2. 
      intros x y. apply (proj1 (I (x,y))).
      apply* spec_curried_2.
      intros x y. destruct~ (I (x,y)).
  intros p. pattern p. induction_wf IH: W p. destruct p as [x y].
  lets C: (spec_curried_2 H). 
  lets I: (spec_is_spec_2 H x y).
  lets S: (spec_elim_2 H x y). clear H. 
  asserts M: (spec_2 (fun x' y' R' => lt (x',y') (x,y) -> K x' y' R') f). split.
    intros x' y'. introv HK HP Lt. applys~ (proj1 (IH _ Lt)).
    apply spec_intro_weak_2.
      intros x' y'. introv HK WR Lt. applys~ (proj1 (IH _ Lt)).
      auto.
      intros x' y' Lt. apply (proj2 (IH _ Lt)).
  split.
    introv HK HP. applys~ (I P P').
    apply~ S.
Qed.

Lemma spec_induction_3 : 
  forall A1 A2 A3 B (lt:(A1*A2*A3)->(A1*A2*A3)->Prop) (Wf: wf lt) f 
         (K:A1->A2->A3->~~B->Prop),
  spec_3 (fun x1 x2 x3 R => 
    spec_3 (fun y1 y2 y3 R' => lt (y1,y2,y3) (x1,x2,x3) -> K y1 y2 y3 R') f ->
    K x1 x2 x3 R) f ->
  spec_3 K f.
Proof.
  introv W H.
  cuts I: (forall p : A1*A2*A3, let '((x,y),z) := p in 
           weakenable (K x y z) /\ K x y z (app_3 f x y z)).
    apply spec_intro_3. 
      intros x y z. apply (proj1 (I (x,y,z))).
      apply* spec_curried_3.
      intros x y z. destruct~ (I (x,y,z)).
  intros p. pattern p. induction_wf IH: W p. destruct p as [[x y] z].
  lets C: (spec_curried_3 H). 
  lets I: (spec_is_spec_3 H x y z).
  lets S: (spec_elim_3 H x y z). clear H. 
  asserts M: (spec_3 (fun x' y' z' R' => lt (x',y',z') (x,y,z) -> K x' y' z' R') f). split.
    intros x' y' z'. introv HK HP Lt. applys~ (proj1 (IH _ Lt)).
    apply spec_intro_weak_3.
      intros x' y' z'. introv HK WR Lt. applys~ (proj1 (IH _ Lt)).
      auto.
      intros x' y' z' Lt. apply (proj2 (IH _ Lt)).
  split.
    introv HK HP. applys~ (I P P').
    apply~ S.
Qed.

Lemma spec_induction_4 : 
  forall A1 A2 A3 A4 B (lt:(A1*A2*A3*A4)->(A1*A2*A3*A4)->Prop) (Wf: wf lt) f 
         (K:A1->A2->A3->A4->~~B->Prop),
  spec_4 (fun x1 x2 x3 x4 R => 
    spec_4 (fun y1 y2 y3 y4 R' => lt (y1,y2,y3,y4) (x1,x2,x3,x4) -> K y1 y2 y3 y4 R') f ->
    K x1 x2 x3 x4 R) f ->
  spec_4 K f.
Proof.
  introv W H.
  cuts I: (forall p : A1*A2*A3*A4, let '(((x,y),z),t) := p in
           weakenable (K x y z t) /\ K x y z t (app_4 f x y z t)).
    apply spec_intro_4. 
      intros x y z t. apply (proj1 (I (x,y,z,t))).
      apply* spec_curried_4.
      intros x y z t. destruct~ (I (x,y,z,t)).
  intros p. pattern p. induction_wf IH: W p. destruct p as [[[x y] z] t].
  lets C: (spec_curried_4 H). 
  lets I: (spec_is_spec_4 H x y z t).
  lets S: (spec_elim_4 H x y z t). clear H. 
  asserts M: (spec_4 (fun x' y' z' t' R' => lt (x',y',z',t') (x,y,z,t) -> K x' y' z' t' R') f). split.
    intros x' y' z' t'. introv HK HP Lt. applys~ (proj1 (IH _ Lt)).
    apply spec_intro_weak_4.
      intros x' y' z' t'. introv HK WR Lt. applys~ (proj1 (IH _ Lt)).
      auto.
      intros x' y' z' t' Lt. apply (proj2 (IH _ Lt)).
  split.
    introv HK HP. applys~ (I P P').
    apply~ S.
Qed.

*)



(*
Lemma spec_iff_app_2 : forall A1 A2 B f (G:A1->A2->~~B),
  (forall K, is_spec_2 K -> (forall x y, K x y (G x y)) -> spec_2 K f) <->
  (forall x H Q, 
     (forall g, (forall y H' Q', G x y H' Q' -> app_1 g y H' Q') -> H ==> Q g) ->
     app_1 f x H Q).
Proof.
  intros. iff M.
  introv S. 
    forwards N: M (fun (x:A1) (y:A2) (R:~~B) => True). intros_all~. auto.
    destruct (pureapp_witness (proj2 N x)) as (g&Sg&Ag). clear Sg N.
    applys pureapp_app_1 Ag. intros g'. apply hextract_prop. intro_subst.  
    apply S. intros y H' Q' Ap.
    forwards N: M (fun (x':A1) (y':A2) (R:~~B) => x' = x -> y' = y -> R H' Q').
       intros_all. subst. applys* H1. 
       intros_all. subst~.
    lets Ag': (proj2 N x). lets Sg: (>>> (@pureapp_join A1 val) Ag Ag').
    apply~ (proj2 Sg y).
  introv Is S. split~. intros x. 
Qed
*)

Lemma pureapp_and_app : forall A B (F:val) (V:A) (V':B) (H:hprop) (Q:B->hprop) h,
  pureapp F V (= V') -> app_1 F V H Q -> H h -> exists H', (Q V' \* H') h.  (* H ==> Q V' \* H' *)
Proof.
  introv (V''&N) M Hh. destruct (N h) as (HE&?). clear N.
  subst. hnf in M. destruct~ (M h heap_empty) as (V''&h1&h2&?&HQ&HE'). 
  do 2 rewrite heap_union_neutral_r in HE'.
  forwards [? R]: (eval_deterministic HE HE').
  subst. exists (=h2). exists h1 h2. rew_disjoint*.
Qed.



Notation "'!!B' x P" := (tag tag_body (Some x) P)
  (at level 95, x at level 0).
Notation "'!!M' x n P" := (tag (tag_match n) (Some x) P)
  (at level 95, x at level 0, n at level 0).
Notation "'!!A' x P" := (tag tag_apply (Some x) P)  
  (at level 95, x at level 0).
Notation "'!!R' x P" := (tag tag_ret (Some x) (local P))  
  (at level 69, x at level 0).
Notation "'!!V' x P" := (tag tag_let_val (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!F' x P" := (tag tag_let_fun (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!T' x P" := (tag tag_let_trm (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!C' x P" := (tag tag_case (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!:W' x P" := (tag tag_casewhen (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!I' x P" := (tag tag_if (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!E' x P" := (tag tag_fail (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!S' x P" := (tag tag_alias (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!D' x P" := (tag tag_done (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!Seq' x P" := (tag tag_seq (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!For' x  P" := (tag tag_for (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!While' x P" := (tag tag_while (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!TV' x P" := (tag tag_top_val (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!TF' x P" := (tag tag_top_fun (Some x) (local P))  
  (at level 95, x at level 0).
Notation "'!!TT' x P" := (tag tag_top_trm (Some x) (local P))  
  (at level 95, x at level 0).

  
(* deprecated 

Notation "'LetVal' : a [ A1 ]  x1 ':=' Q1 'in' Q2" :=
  (!!L a (fun P => exists P1, (forall A1, Q1 P1)
                            /\ forall x1,P1 x1 -> Q2 P))
  (at level 69, a at level 0, x1 ident, A1 ident) : charac.

Notation "'LetVal' : a [ A1 A2 ]  x1 ':=' Q1 'in' Q2" :=
  (!!L a (fun P => exists P1, (forall A1 A2, Q1 P1)
                            /\ forall x1,P1 x1 -> Q2 P))
  (at level 69, a at level 0, x1 ident, A1 ident, A2 ident) : charac.
*)


(* deprecated

Notation "'LetVal' x1 ':=' Q1 'in' Q2" :=
  (!L (fun P => exists P1, Q1 P1 
                           /\ forall x1,P1 x1 -> Q2 P))
  (at level 69, x1 ident) : charac.

Notation "'LetVal' [ A1 ]  x1 ':=' Q1 'in' Q2" :=
  (!L (fun P => exists P1, (forall A1, Q1 P1)
                            /\ forall x1,P1 x1 -> Q2 P))
  (at level 69, x1 ident, A1 ident) : charac.

Notation "'LetVal' [ A1 A2 ]  x1 ':=' Q1 'in' Q2" :=
  (!L (fun P => exists P1, (forall A1 A2, Q1 P1)
                            /\ forall x1,P1 x1 -> Q2 P))
  (at level 69, x1 ident, A1 ident, A2 ident) : charac.
*)

(*--older while
Notation "'While' Q1 'Do' Q2 'Done'" :=
  (!While (fun H Q => exists H', exists A, exists I, exists R,
       wf R 
     /\ (exists x, H ==> I x \* H')
     /\ (forall x, local (fun Hl Ql => exists Q', 
            Q1 Hl Q'
         /\ Q2 (Q' true) (# Hexists y, (I y) \* [R y x])
         /\ (Q' false \* H' ==> Ql tt)) (I x) Q)))
  (at level 69) : charac.
*)

(*--old while
Notation "'While' Q1 'Do' Q2 'Done'" :=
  (!While (fun H Q => exists H', exists A, exists I, exists J, exists R,
       wf R 
     /\ (exists x, H ==> I x \* H')
     /\ (forall x, 
            Q1 (I x) (J x)
         /\ Q2 (J x true) (# Hexists y, (I y) \* [R y x])
         /\ J x false \* H' ==> Q tt)))
  (at level 69) : charac.
*)

Notation "'For' i '=' a 'To' b 'Do' Q1 'Done'" :=
  (!For (fun H Q => (a > (b)%Z -> H ==> (Q tt)) /\ (a <= (b)%Z -> exists H', exists I,
       (H ==> I a \* H') 
    /\ (forall i, a <= i /\ i <= (b)%Z -> Q1 (I i) (# I(i+1))) 
    /\ (I ((b)%Z+1) \* H' ==> Q tt))))
  (at level 69, i ident) : charac.


(*

Notation "'LetFuncs' a f1 ':=' Q1 'in' F" :=
  (!!F a fun H Q => forall f1, exists P1,
     (Q1 -> P1 f1) /\ (P1 f1 -> F H Q))
  (at level 69, a at level 0, f1 ident, only parsing) : charac.

Notation "'LetFun_' a f x ':=' Q 'in' F" :=
  (LetFuncs a f := (Body f x => Q) in F)
  (at level 69, a at level 0, f ident, x ident) : charac.




(*

Lemma xfor_frame : forall I H' a b H Q (Pof:(int->hprop)->Prop),
  (forall H', Pof I -> Pof (I \*+ H')) ->
  (a > (b)%Z -> H ==> (Q tt)) ->
  ((a <= (b)%Z) -> 
      (H ==> I a \* H') 
   /\ (Pof I)
   /\ (I ((b)%Z+1) \* H' ==> Q tt)) ->
  local (fun H Q => (a > (b)%Z -> H ==> (Q tt)) /\ (a <= (b)%Z -> exists I,
     H ==> I a /\ Pof I /\ (I ((b)%Z+1) ==> Q tt))) H Q.
Proof.
  introv L M1 M2. apply local_erase. split. auto.
  introv M3. intuit (M2 M3). exists (I \*+ H'). splits*.
Qed.

Lemma xfor_frame_le : forall I H' a b H Q (Pof:(int->hprop)->Prop),
  (a <= (b)%Z) -> 
  (H ==> I a \* H') ->
  (Pof I) ->
  (I ((b)%Z+1) \* H' ==> Q tt) ->
  local (fun H Q => (a > (b)%Z -> H ==> (Q tt)) /\ (a <= (b)%Z -> exists I, 
     H ==> I a /\ Pof I /\ (I ((b)%Z+1) ==> Q tt))) H Q.
Proof.
  introv M1 M2 M3 M4. apply~ (>>> local_wframe unit __ H' (fun _:unit => I (b+1))).
  apply local_erase. split. intros. false. math.
  intros. exists* I. intros t. destruct t. auto.
Qed.

Lemma xwhile_frame : forall A I (R:binary A) H' H Q Qf (F1:~~bool) (F2:~~unit),
  is_local F1 -> 
  is_local F2 -> 
  wf R ->
  (exists x, H ==> I x \* H') ->
  (forall x, local (fun Hl Ql => exists Q', 
            F1 Hl Q'
         /\ F2 (Q' true) (# Hexists y, (I y) \* [R y x])
         /\ (Q' false ==> Ql tt)) (I x) Qf) ->
  (Qf \*+ H' ===> Q) ->
  local (fun H Q => exists A, exists I, exists R:binary A,
       wf R 
     /\ (exists x, H ==> I x)
     /\ (forall x, local (fun Hl Ql => exists Q', 
            F1 Hl Q'
         /\ F2 (Q' true) (# Hexists y, (I y) \* [R y x])
         /\ (Q' false ==> Ql tt)) (I x) Q )) H Q.
Proof.
  introv L1 L2 M1 (X0,M2) M3 M4. 
  apply* local_wframe.
  apply local_erase.
  exists A I R. splits*.
Qed.

*)




    
(*

lets M : @ml_array_get_spec.
eapply spec_elim_2_2.

evar (a:Type); let t := constr:(Inhab a) in
 let t' := eval unfold a in t in 
assert (x:t'); subst a; [  | pose (M _ x) ].
skip. apply s0.

forwards: M.
lets: (M Z _). apply H.
evar (a:Type); let t := constr:(Inhab a) in
 let t' := eval unfold a in t in 
evar (x:t');
eapply (M _ x).
evar (a:Type);
evar (x:Inhab a);
lets: (H a x); subst a x. 
Show Existentials.
 lets: (>>> Args H __ a).
*)





Parameter ml_array_get_spec : forall `{Inhabited a},
  Spec ml_array_get (l:loc) (i:int) |R>> 
    forall (t:array a), index t i ->
    keep R (l ~> Array Id t) (\= t\(i)).

Parameter ml_array_set_spec : forall a,
  Spec ml_array_set (l:loc) (i:int) (v:a) |R>> 
    forall (t:array a), index t i -> 
    R (l ~> Array Id t) (# l ~> Array Id (t\(i:=v))).
      (* (# Hexists t', l ~> Array Id t' \* [t' = t\(i:=v)]).*)

(* BIN
Parameter ml_array_make_spec : forall a A,
  Spec ml_array_make (n:int) (v:a) |R>> 
    forall (V:A) (T:htype A a) (t:array A), Dup T ->
    R (T V v) (fun l => l ~> Array T (array_make n V)).

Parameter ml_array_get_spec : forall a A `{Inhab A},
  Spec ml_array_get (l:loc) (i:int) |R>> 
    forall (T:htype A a) (t:array A), Dup T -> index t i ->
    Read (R:~~a) (l ~> Array T t) (T (t`[i])).

Parameter ml_array_set_spec : forall a A `{Inhab A},
  Spec ml_array_set (l:loc) (i:int) (v:a) |R>> 
    forall (V:A) (T:htype A a) (t:array A), Dup T -> index t i -> 
    R (l ~> Array T t \* T V v) (# l ~> Array T (t`[i:=V])).
*)

(* deprecated
Definition Base A (X:A) (x:A) := 
  [ x = X ].

Implicit Arguments Base [[A]].
*)
Definition Read B (R:~~B) := 
  fun H Q => R H (Q \*+ H).


(*

Parameter ml_array_make_spec : forall a,
  Spec ml_array_make (n:int) (v:a) |R>> 
    R [] (_~> ArrayOn (Array.make n V)).

Parameter ml_array_get_spec : forall a A,
  Spec ml_array_get (l:loc) (i:int) |R>> 
    index t i -> read R (l ~> ArrayOn t) (= t\[i]).

Parameter ml_array_set_spec : forall a,
  Spec ml_array_set (l:loc) (i:int) (v:a) |R>> 
    index t i -> R (l ~> ArrayOn t) (# l ~> ArrayOn t'[i:=v]).

*)



Lemma test_omega : forall x,
  let y := x in
  2 + x = y + 2.
Proof. intros. try omega. unfold y. omega. Qed.

   Lemma array_update_length : forall `{Inhab A} (t:array A) (i:int) (v:A),
     index t i -> (t\(i:=v))\(i) = v.
  Admitted.



Definition y := 3.
Lemma test_omega' : y + 2 = 5.
Proof. intros. try omega. unfold y. omega. Qed.



(*
Lemma inbound_spec :
  Specs inbound i >> [] (\= istrue (index L i)).
Proof.
  xcf. intros. xret. hsimpl.
  extens. rew_logicb. rewrite* int_index_def.
Qed.

Hint Extern 1 (RegisterSpec inbound) => Provide inbound_spec.
*)





Lemma le_succ : forall n, n <= n +1.
Proof. math. Qed.
Hint Resolve le_succ.

(*
Hint Resolve int_index_le int_index_prove.
Hint Resolve array_index_prove index_array_length.
Hint Resolve length_update_prove.
*)


(* BIN
Ltac myunfolds := unfolds good_sizes, Valid.
Ltac auto_star ::= try solve [intuition eauto]. (* jauto => should splitt iff *)
Ltac auto_tilde ::= try solve [auto].
Ltac autom := myunfolds; auto with maths.
*)




(* -- temp
Hint Extern 1 (@index _ _ int_index ?m ?i) =>
  myunfold; match goal with H: @index _ _ int_index ?n i |- _ => 
    eapply (@int_index_le i n m); math end : strong.

Hint Extern 3 (@index _ _ int_index ?m ?i) =>
  myunfold; eapply int_index_prove; math : strong.

Hint Extern 3 (@index _ _ (array_index _) ?t ?i) =>
  myunfold; match goal with H: @index _ _ int_index ?n i |- _ => 
    eapply index_array_length_le; math end : strong.

Ltac strong := eauto with strong.
 --*)


Ltac strong' := skip.


(** Heap representation for pure data types *)

Definition Pure `{Rep a A} (X:A) (x:a) := 
  [ rep x X ].





---------
(*
Lemma E_Ass' : forall st a1 l,
      (l ::= a1) / st ==> (update st l (aeval st a1)).
Proof. intros. apply E_Ass. auto. Qed.
Hint Resolve E_Ass'.

Lemma beval_false : forall st b,
 beval st b = false -> ~ bassn b st.
Proof. intros. unfold bassn. rewrite~ H. Qed. 
Hint Resolve beval_false.
*)

(
Ltac introeq := 
  let x := fresh in intros x; intro; subst x.

Definition bassn b : Assertion :=
  fun st => beval st b = true.




(*****************************************************************************)
(** From characteristic formulae to Hoare triples *)

(** Definition of Hoare triples *)

Definition hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop :=
  forall st st', 
       c / st ==> st' ->
       P st ->
       Q st'.

Notation "{{ P }} c {{ Q }}" := (hoare_triple P c Q) (at level 90).


(* to get somewhere else *)
Axiom deterministic : forall c st st' st'',
  c / st ==> st' -> 
  c / st ==> st'' ->
  st' = st''.

Lemma cf_to_hoare : forall (c:com) (P Q:Assertion), 
  cf c P Q  ->  {{P}} c {{Q}}. 
Proof.
  introv Hcf Red Pre.
  forwards* [st'' [Red' Post]]: (>>> cf_sound Hcf).
  forwards* E: (>>> deterministic Red Red').
  rewrite~ E.
Qed.


Lemma assignement : forall st V X,
  update st V (aeval st (AId X)) V = st X.
Proof.
  intros. unfold aeval, update. rewrite~ beq_id_refl.
Qed.




(*

  (* verification of f *)
  xfun (fun f => Spec f x |R>> forall y f',
     let I := (r ~> Ref Id f') in
     (Spec f' x' |R'>> forall y', lt (y',x') (y,x) -> sframe I (L y') x' R') ->
     sframe I (L y) x R).
    intros I Sf'. applys Is.
      apply (spec_elim_2 (Hbigf I) g x y). xweaken.
       simpl. intros x' R LR SK. unfold sframe in SK|-*.
       apply SK; [ xisspec | apply Sf' ].
      intros H Q Happ. apply Happ.
  (* tie the knot *)
  xapp. xret. hsimpl (r ~> Ref Id f).
  (* prove the spec of the result by induction *)
  xinduction_heap W. xweaken~.*)


(*bin*)
 (* intros_all. applys~ sframe_is_spec_1.*)
 (*ntros_all. applys sframe_is_spec_1. auto. apply H. auto.*)
(*intros_all. applys sframe_is_spec_1. auto. apply H. auto. auto.*)




Ltac unfold_id_in H :=
  match H with context[?x ~> Id ?X] =>
     change (x ~> Id X) with ([X = x]) end.

Ltac unfold_id_left tt :=
  repeat match goal with |- ?H ==> _ => unfold_id_in H end.

Ltac unfold_id_right tt :=
  repeat match goal with |- _ ==> ?H => unfold_id_in H end.

(* Lemma test_unfold_id_left : forall A (x y:A), x ~> Id y ==> []. 
intros. unfold_id_left tt. *)

Ltac unfold_id_pre tt :=
  repeat hclean_onH ltac:(fun H => unfold_id_in H).
v  unfold_id_pre tt;

Notation "'If__' x 'Then' Q1 'Else' Q2" :=
  (!I (fun H Q => (x = true -> Q1 H Q) /\ (x = false -> Q2 H Q)))
  (at level 69, x at level 0) : charac.



Notation "'While' Q1 'Do' Q2 'Done'" :=
  (!While (fun H Q => forall R:~~unit, is_local R ->
        (forall H Q, (exists Q', Q1 H Q' 
           /\ (local (fun H Q => exists Q'', Q2 H Q'' /\ R (Q'' tt) Q) (Q' true) Q)
           /\ Q' false ==> Q tt) -> R H Q) 
        -> R H Q))
  (at level 69) : charac.

Notation "'For' i '=' a 'To' b 'Do' Q1 'Done'" :=
  (!For (fun H Q => forall S:int->~~unit, is_local_1 S ->
        (forall i H Q,  
             ((i <= (b)%Z -> (local (fun H Q => exists Q', Q1 H Q' /\ S (i+1) (Q' tt) Q) H Q))
          /\ (i > b%Z -> (Ret tt) H Q)) 
          -> S i H Q)
       -> S a H Q)) 
  (at level 69) : charac.





Ltac asserts_apply_core E cont := 
  let H := fresh "TEMP" in asserts H: E; [ | applys H; cont tt ].

Tactic Notation "asserts_apply" constr(E) :=
  asserts_apply_core E idcont.

Tactic Notation "asserts_apply" "~" constr(E) :=
  asserts_apply_core E ltac:(fun _ => auto_tilde).
Tactic Notation "asserts_apply" "*" constr(E) :=
  asserts_apply_core E ltac:(fun _ => auto_star).


(*
Lemma himpl_id : forall H1 H2 : hprop,
  H1 ==> H2 -> H1 ==> H2.
Proof. auto. Qed.
Implicit Arguments himpl_id [H1 H2].
*)



Ltac hchange_debug H :=
  let K := fresh "TEMP" in
  forwards_nounfold K: H; eapply hchange_lemma; 
    [ apply K
    | clear K
    | clear K ].

Ltac hchange_core H :=
  let K := fresh "TEMP" in
  forwards_nounfold K: H; eapply hchange_lemma; 
    [ apply K
    | clear K; instantiate; try hsimpl
    | clear K; instantiate ].

Tactic Notation "hchange" constr(H) :=
  hchange_core H.
Tactic Notation "hchange" "~" constr(H) :=
  hchange_core H; auto_tilde.
Tactic Notation "hchange" "*" constr(H) :=
  hchange_core H; auto_star.






Ltac xchange_debug L :=
  let K := fresh "K" in
  forwards_nounfold K: L; eapply xchange_lemma;
    [ clear K; try xlocal
    | apply K
    | clear K
    | clear K ].

Ltac xchange_lemma_core L :=
  let K := fresh "TEMP" in
  forwards_nounfold K: L; eapply xchange_lemma; 
    [ clear K; try xlocal
    | apply K
    | clear K; instantiate; hsimpl
    | clear K ].

Ltac xchange_with_core H H' :=
  eapply xchange_lemma with (H1:=H) (H1':=H'); 
    [ try xlocal
    | 
    | hsimpl
    | ].

Ltac xchange_core E :=
  match E with
  | ?H ==> ?H' => xchange_with_core H H'
  | _ => xchange_lemma_core E
  end.

Tactic Notation "xchange" constr(E) :=
  xchange_core E.
Tactic Notation "xchange" "~" constr(E) :=
  xchange E; auto~.


Set Implicit Arguments.
Require Import LibCore CFPrim Counter_ml.

(*------------------------------------------------------------------*)
(* code:

let gensym () =
   let x = ref 0 in
   let f () = 
      let n = !x in
      x := n+1;
      n in
   f

*)

(*------------------------------------------------------------------*)

Definition counter_spec I f :=
  Spec f () |R>> forall n, R (I n) (\=n \*+ (I (n+1))).

Definition Counter (n:int) (f:func) :=
  Hexists I:int->hprop, (I n) \* [counter_spec I f].

Lemma gensym_spec : Spec gensym () |R>>
  R [] (fun f => f ~> Counter 0).
Proof.
  unfold Counter, hdata. xgo.
  sets I: (fun n:int => x ~> Ref Id n).
  xfun (counter_spec I). xgo*. xret. hsimpl~ I.
Qed.

Definition localize B (H:hprop) (Q:B->hprop) (R:~~B) :=
  local R H Q.

Lemma local_weaken_formula : forall B (F1 F2:~~B) H Q,
  local F1 H Q -> (F1 ===> F2) -> local F2 H Q.
Proof.
  introv M W. introv Hh.
  destruct (M h Hh) as (?&?&?&?&?&?&?).
  exists___. splits; [ | apply W; apply H1 |]. eauto. eauto. 
Qed.

Lemma app_spec_2' : forall A1 A2 B f (v1:A1) (v2:A2) (H:hprop) (Q : B->hprop),
  spec_2 (fun x1 x2 R => x1 = v1 -> x2 = v2 -> 
    (forall H Q, R H Q -> app_2 f v1 v2 H Q) -> R H Q) f ->
  app_2 f v1 v2 H Q.
Proof. introv S. forwards~ K : (spec_elim_2 S). Qed.
(* to simpler *)


Lemma iter_spec' : forall A,
  Spec iter (f:func) (l:list A) | R>>
    forall H (Q:unit->hprop),
    (forall (S:list A -> _ -> _ -> Prop),
       (forall l, is_local (S l)) ->
       (match l with 
       | nil => H ==> Q tt
       | x::l' =>      
          localize H Q (fun (H:hprop) (Q:unit->hprop) => 
             exists Q':unit->hprop,
             app_1 f x H Q' /\ S l (Q' tt) Q)
       end -> S l H Q) -> 
      S l H Q) -> 
   R H Q.
Proof.
Admitted.
(*
  intros. xintros. intros f l H Q M.
(*
  specializes M (@app_2 Func (list A) unit iter f).  
  forwards J: (iter_cf (K:= fun f' l' R => f' = f -> l' = l -> R H Q));
   [ | | ]. skip. skip. lets: (spec_elim_2 J).
*)
 sets_eq S: (app_2 (A1:=val) (A2:=list A) (B:=unit) iter f). 
 (*   specializes M S. *)
  (* gen M. induction_wf IH: (@list_sub_wf A) l. intros M. apply M. *)
  apply M; clear M.
  intros v.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
    xmatch. xret~.
  intros x t J.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
   xmatch.
   applys local_weaken_formula J. clears H Q. intros H Q. intros (Q'&J1&J2). 
   exists (Q' tt). split. skip. (* todo : fix apply J1. *) apply J2.
Qed.
*)



Lemma iter_spec : forall A,
  Spec iter (f:func) (l:list A) | R>>
    forall H (Q:unit->hprop),
    (forall (S:list A -> _ -> _ -> Prop),
       (forall l, is_local (S l)) ->
       (forall H Q, H ==> Q tt -> S nil H Q) ->
       (forall H Q x l,
          (localize H Q (fun (H:hprop) (Q:unit->hprop) => 
             exists Q':unit->hprop,
             app_1 f x H Q' /\ S l (Q' tt) Q) -> S (x::l) H Q)) ->
      S l H Q) -> 
   R H Q.
Proof.
  intros. xintros. intros f l H Q M.
(*
  specializes M (@app_2 Func (list A) unit iter f).  
  forwards J: (iter_cf (K:= fun f' l' R => f' = f -> l' = l -> R H Q));
   [ | | ]. skip. skip. lets: (spec_elim_2 J).
*)
 sets_eq S: (app_2 (A1:=val) (A2:=list A) (B:=unit) iter f). 
 (*   specializes M S. *)
  (* gen M. induction_wf IH: (@list_sub_wf A) l. intros M. apply M. *)
  apply M; clear M H Q.
  rewrite EQS. intros. xlocal.
  intros H Q v.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
    xmatch. xret~.
  intros H Q x t J.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
   xmatch.
   applys local_weaken_formula J. clears H Q. intros H Q. intros (Q'&J1&J2). 
   exists (Q' tt). split. skip. (* todo : fix apply J1. *) apply J2.
Qed.

Hint Extern 1 (RegisterSpec iter) => Provide iter_spec.


Lemma hsimpl_to_qunit' : forall (H:hprop),
  H ==> (fun _ => H) tt.
Proof. intros. subst. auto. Qed.
Hint Resolve hsimpl_to_qunit'.

Lemma test_spec : 
  Spec test (l:list func) |R>>
    forall L, 
    R (l ~> List Counter L) (# l ~> List Counter (LibList.map (fun i => i+1) L)).
Proof.
  xcf. intros l L. 
  xfun (fun g => Spec g f |R>> 
     forall (Q':int->hprop) H (Q:unit->hprop),
     app_1 f tt H Q' -> 
     (forall x, Q' x ==> Q tt) ->
     R H Q).
     intros M W. xlet. apply M. xret~.
   renames _f0 to g, S_f0 to Sg.
  xuntag. apply ( spec_elim_2 (@iter_spec func)).
  intros S LS Jn Jc.
  gen L. induction l as [|f l]; intros L.
  apply Jn. clear Jn Jc.
   hchange (@unfocus_nil' _ L _ Counter).
   hextract. subst. Opaque List.
   hchange (@focus_nil _ _ Counter). hsimpl.
 apply Jc. clear Jn Jc.
  unfold localize.  
  xchange (focus_cons' f l).
   xextract as n L' E. subst L.
   unfold Counter at 1.
   unfold hdata at 1.
   xextract as I HI. unfolds in HI.
   apply local_erase. esplit. split.
   eapply (spec_elim_1 Sg).
change (app_1 (B:=Z) f tt)
 with (tag tag_apply None (app_1 (B:=Z) f tt)).
xapp.
intros x. simpl. hextract. apply~ hsimpl_to_qunit.
 simpl. eapply local_wframe.
auto. apply ( IHl L'). hsimpl.
 hsimpl.
Qed.



 xuntag. 

 let f := spec_goal_fun tt in
      xfind f; let H := fresh in intro H.
Ieapply spec_elim_1.      
xapp_spec_core H idcont.
; clear H

xapp_core __ idcont.  
xapp_manual.

    apply (spec_elim_1 HI).
 (* todo: add tags*)
  apply (spec_elim_1 Sg).
  xchange (focus_cons' f l). 

 (* todo*)

  xextract I.
 
  


 hsimpl.  destruct  appl.
 apply H.
  apply local_erase. n a pply spec_elim
  xapp_manual.
  apply KR; clear KR. intros S Jn Jc. 
  
  destruct l.
  

Qed.

(*
  (* gen M. induction_wf IH: (@list_sub_wf A) l. intros M. apply M. *)
  apply M.
  intros v.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
    xmatch. xret~.
  intros x t J.
     rewrite EQS. eapply app_spec_2. xcf. intros. subst.
     xmatch.
    eapply local_weaken_formula. apply J. clears H Q. intros H Q.
    intros (Q'&J1&J2). 
    exists (Q' tt). split. skip. (* todo : fix apply J1. *) apply J2.
Qed
     rewrite EQS. eapply app_spec_2. xcf. intros. subst.
     xmatch.
    eapply local_weaken_formula. apply J. clears H Q. intros H Q.
    intros (Q'&J1&J2). 
    exists (Q' tt). split. skip. (* todo : fix apply J1. *) apply J2.
Qed.*)

  rewrite 

QeEQS.
  forwards J: iter_cf. skip. skip.
  
eapply (spec_elim_2 J).
 eapply app_spec_2.
  apply 
  xcf. intros. subst. 
  xmatch. xret. auto.
subst. xmatch. xret~.  
  forwards J: (iter_cf (K:= fun f' l' R => f' = f -> l' = l -> R H Q));
   [ | | apply~ (spec_elim_2 J) ].
  intros_all~.

; [ | | lets: (sp_elim_2 J) ].
skip.
skip.
.

eapply app_spec_2. 
apply spec_intro_2. skip. skip. intros.
apply H0.
 skip.
  sets_eq S: (app_2 (A1:=val) (A2:=list A) (B:=unit) iter f). 
 (*   specializes M S. *)
  (* gen M. induction_wf IH: (@list_sub_wf A) l. intros M. apply M. *)
  apply M.
  intros v.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
    xmatch. xret~.
  intros x t J.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
   xmatch.
   applys local_weaken_formula J. clears H Q. intros H Q. intros (Q'&J1&J2). 
   exists (Q' tt). split. skip. (* todo : fix apply J1. *) apply J2.
Qed.

Lemma test_spec : 
  Spec test (l:list func) |R>>
    forall L, 
    R (l ~> List Counter L) (l ~> List Counter (map S L)).


(*
  (* gen M. induction_wf IH: (@list_sub_wf A) l. intros M. apply M. *)
  apply M.
  intros v.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
    xmatch. xret~.
  intros x t J.
     rewrite EQS. eapply app_spec_2. xcf. intros. subst.
     xmatch.
    eapply local_weaken_formula. apply J. clears H Q. intros H Q.
    intros (Q'&J1&J2). 
    exists (Q' tt). split. skip. (* todo : fix apply J1. *) apply J2.
Qed.*)

  rewrite EQS.
  forwards J: iter_cf. skip. skip.
  
eapply (spec_elim_2 J).
 eapply app_spec_2.
  apply 
  xcf. intros. subst. 
  xmatch. xret. auto.
subst. xmatch. xret~.

 apply M.
 
 induction l; intros.
  apply M.
  intros V. rewrite EQS. eapply app_spec_2. xcf. intros. subst. xmatch. xret~.

  intros x l V. rewrite EQS. eapply app_spec_2. xcf. intros. subst. xmatch.  
  eapply local_weaken_formula. apply V. clears H Q. intros H Q.
  intros (Q'&J1&J2). 
  exists (Q' tt). split. skip. (* todo : fix apply J1. *)
  apply J2.

  
  eapply M.
  Qed.
  




(* Details of the proof:

  xcf. xgo. 
  xfun (counter_spec (fun n => x ~> RefOn n)).
    xapp. intro_subst. xapp. xret. ximpl~.
  xret. ximpl~.

*)

(* details of hsimpl:

hsimpl_setup tt.
hsimpl_step tt.
apply hsimpl_cancel_eq_1.
eapply refl_equal.
hsimpl_step tt.
hsimpl_step tt.
hsimpl_step tt.

*)



Lemma iter_spec : forall A,
  Spec iter (f:func) (l:list A) | R>>
    forall H (Q:unit->hprop),
    (forall (S:list A -> _ -> _ -> Prop),
       (forall H Q, H ==> Q tt -> S nil H Q) ->
       (forall H Q x l,
          (localize H Q (fun (H:hprop) (Q:unit->hprop) => 
             exists Q':unit->hprop,
             app_1 f x H Q' /\ S l (Q' tt) Q) -> S (x::l) H Q)) ->
      S l H Q) -> 
   R H Q.
Proof.
  intros. xintros. intros f l H Q M.
(*
  specializes M (@app_2 Func (list A) unit iter f).  
  forwards J: (iter_cf (K:= fun f' l' R => f' = f -> l' = l -> R H Q));
   [ | | ]. skip. skip. lets: (spec_elim_2 J).
*)
 sets_eq S: (app_2 (A1:=val) (A2:=list A) (B:=unit) iter f). 
 (*   specializes M S. *)
  (* gen M. induction_wf IH: (@list_sub_wf A) l. intros M. apply M. *)
  apply M; clear M H Q.
  intros H Q v.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
    xmatch. xret~.
  intros H Q x t J.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
   xmatch.
   applys local_weaken_formula J. clears H Q. intros H Q. intros (Q'&J1&J2). 
   exists (Q' tt). split. skip. (* todo : fix apply J1. *) apply J2.
Qed.



Lemma iter_spec : forall A,
  Spec iter (f:func) (l:list A) | R>>
    forall H (Q:unit->hprop),
    (forall (S:list A -> _ -> _ -> Prop),
       (forall, H ==> Q tt -> S nil H Q) ->
       (forall x l,
          (localize H Q (fun (H:hprop) (Q:unit->hprop) => 
             exists Q':unit->hprop,
             app_1 f x H Q' /\ S l (Q' tt) Q) -> S (x::l) H Q)) ->
      S l H Q) -> 
   R H Q.
Proof.
  intros. xintros. intros f l H Q M.
(*
  specializes M (@app_2 Func (list A) unit iter f).  
  forwards J: (iter_cf (K:= fun f' l' R => f' = f -> l' = l -> R H Q));
   [ | | ]. skip. skip. lets: (spec_elim_2 J).
*)
 sets_eq S: (app_2 (A1:=val) (A2:=list A) (B:=unit) iter f). 
 (*   specializes M S. *)
  (* gen M. induction_wf IH: (@list_sub_wf A) l. intros M. apply M. *)
  apply M; clear M.
  intros v.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
    xmatch. xret~.
  intros x t J.
    rewrite EQS. eapply app_spec_2. xcf. intros. subst.
   xmatch.
   applys local_weaken_formula J. clears H Q. intros H Q. intros (Q'&J1&J2). 
   exists (Q' tt). split. skip. (* todo : fix apply J1. *) apply J2.
Qed.

Hint Extern 1 (RegisterSpec iter) => Provide iter_spec.



(*
Hint Rewrite <- star_assoc : hsimpl_assoc.
Hint Rewrite star_neutral_l star_neutral_r : hsimpl_neutral.
*)

(*
Lemma hextract_last : forall H1 H2 H',
  (H2 \* H1)  ==> H' -> H1 \* H2 ==> H'.
Proof. intros. rewrite (star_comm H2) in H. auto. Qed.
*)

(*
Lemma hextract_prop : forall H1 H' (P:Prop),
  (P -> H1 \* [] ==> H') -> H1 \* [P] ==> H'.
Proof.
  introv W. intros h Hh.
  destruct Hh as (h1&h2'&?&(?&?)&?&?).
  apply~ W. subst. rew_heap. rewrite~ heap_union_neutral_r.
Qed.
*)
(*
Lemma hextract_id : forall A (x X : A) H1 H',
  (x = X -> H1 \* [] ==> H') -> H1 \* (x ~> Id X) ==> H'.
Proof. intros. unfold Id. apply~ hextract_prop. Qed.
*)

(*
Lemma hextract_exists : forall A H1 H' (J:A->hprop),
  (forall x, H1 \* J x ==> H') -> H1 \* (heap_is_pack J) ==> H'.
Proof.  
  introv W. intros h Hh. destruct Hh as (h1&h2'&?&(x&?)&?&?).
  applys~ W x. exists h1 h2'. subst h. splits~. 
Qed.
*)
  end end.

(*
  | [_] => apply hextract_prop; intros
  | _ ~> Id _ => apply hextract_id; intros
  | heap_is_pack _ => apply hextract_exists; intros
  | _ => apply hextract_last
*)

Ltac hsimpl_extract_exists_with_hints tt :=
  match goal with |- ?HL ==> ?HA \* (heap_is_pack ?J \* ?HR) =>
    hsimpl_hint_next ltac:(fun x =>
      match x with
      | __ => eapply hsimpl_extract_exists
      | _ => apply (@hsimpl_extract_exists _ x)
      end)
  end.

Ltac hsimpl_extract_exists_step tt :=
  first [ hsimpl_extract_exists_with_hints tt
        | eapply hsimpl_extract_exists ];
   autorewrite with hsimpl_assoc.


(* deprecated
Lemma hsimpl_demo_5 : forall n J H,
  n = 2 ->
  J n \* H ==> H \* Hexists y, [y <> 3] \* J y.
Proof.
  intros. dup 3.
  hsimpl. math.
  hsimpl n. math.
  hsimpl 2. subst~. math.
Qed.
*)




Ltac hclean_protect tt :=
  let Q' := fresh "TEMP" in
  hclean_onQ ltac:(fun Q => set (Q' := Q : ltac_tag_subst _));
  do 5 try (hclean_onH ltac:(fun H => protect_evars_in H); instantiate).

Ltac hclean_relinearize tt :=
  let go Hpre := match Hpre with ?H \* (_ \* _) =>
    let T := fresh "TEMP" in 
    sets T: H; 
    autorewrite with hsimpl_assoc; 
    subst T
    end in
  hclean_onH ltac:(go).
 






(********************************************************************)
(* ** Simplification and unification tactics for star *)

Ltac check_goal_himpl tt :=
  match goal with 
  | |- @rel_le unit _ _ _ => let t := fresh "_tt" in intros t; destruct t
  | |- @rel_le _ _ _ _ => let r := fresh "r" in intros r
  | |- pred_le _ _ => idtac
  end.

Ltac protect_evars_in H :=
   match H with context [ ?X ] =>
     let go tt := 
       match X with
       | _ \* _ => fail 1
       | X => fail 1 
       | ?x ~> ?R => 
           match x with
           | x => idtac             
           | _ => fail 20 "Uninstantiated argument at left of ~>"
           end;
           let TR := type of R in
           let K := fresh "TEMP" in 
           sets_eq K: (R : ltac_tag_subst TR)
       | [ ?R ] => 
           let TR := type of R in
           let K := fresh "TEMP" in 
           sets_eq K: (R : ltac_tag_subst TR)
       | _ => let K := fresh "TEMP" in
              sets_eq K: (X : ltac_tag_subst hprop)
       end in
     match type of X with 
     | hprop => go tt
     | heap -> Prop => go tt
     end
  end.


Ltac protect_evars_debug :=
  match goal with |- _ ==> ?H => protect_evars_in H end.

Ltac protect_evars tt :=
  do 5 try match goal with |- ?H1 ==> ?H2 =>
     first [ protect_evars_in H1 | protect_evars_in H2 ]; instantiate
  end.

Ltac unprotect_evars tt :=
  repeat match goal with H : ltac_tag_subst _ |- _ => 
    subst H end;
  unfold ltac_tag_subst.

Hint Rewrite <- star_assoc : hsimpl_assoc.
Hint Rewrite star_neutral_l star_neutral_r : hsimpl_neutral.

Lemma hextract_start : forall H H',
  [] \* (H \* []) ==> H' -> H ==> H'.
Proof. intros. rew_heap in *. auto. Qed.

Lemma hextract_keep : forall H1 H2 H3 H',
  (H1 \* H2) \* H3 ==> H' -> H1 \* (H2 \* H3) ==> H'.
Proof. intros. rew_heap in *. auto. Qed.

Lemma hextract_prop : forall H1 H2 H' (P:Prop),
  (P -> H1 \* H2 ==> H') -> H1 \* ([P] \* H2) ==> H'.
Proof.
  introv W. intros h Hh.
  destruct Hh as (h1&h2'&?&(h2&h3&(?&?)&?&?&?)&?&?).
  apply~ W. exists h1 h3. subst h h2 h2'.
  splits~. rewrite~ heap_union_neutral_l.
Qed.

Lemma hextract_id : forall A (x X : A) H1 H2 H',
  (x = X -> H1 \* H2 ==> H') -> H1 \* (x ~> Id X \* H2) ==> H'.
Proof. intros. unfold Id. apply~ hextract_prop. Qed.

Lemma hextract_exists : forall A H1 H2 H' (J:A->hprop),
  (forall x, H1 \* J x \* H2 ==> H') -> H1 \* (heap_is_pack J \* H2) ==> H'.
Proof.  
  introv W. intros h Hh.
  destruct Hh as (h1&h2'&?&(h2&h3&(?&?)&?&?&?)&?&?).
  applys~ W x. exists h1 (heap_union h2 h3). subst h h2'.
  splits~. exists h2 h3. splits~.
Qed.

Ltac hextract_setup tt :=
  lets: ltac_mark;
  apply hextract_start;
  protect_evars tt; 
  autorewrite with hsimpl_assoc.

Ltac hextract_cleanup tt :=
  autorewrite with hsimpl_assoc;
  autorewrite with hsimpl_neutral;
  unprotect_evars tt; 
  gen_until_mark.

Ltac hextract_relinearize tt :=
  match goal with |- ?H \* (_ \* _) ==> _ =>
    let T := fresh "TEMP" in 
    sets T: H; 
    autorewrite with hsimpl_assoc; 
    subst T
  end.

Ltac hextract_step tt :=
  match goal with |- ?HA \* (?H \* ?HR) ==> ?H' =>
  first [ apply hextract_prop; intros
        | apply hextract_id; intros
        | apply hextract_exists; intros; hextract_relinearize tt
        | apply hextract_keep ]
  end.

Ltac post_impl_intro tt :=
  match goal with 
  | |- @rel_le unit _ _ _ => let t := fresh "_tt" in intros t; destruct t
  | |- @rel_le _ _ _ _ => let r := fresh "r" in intros r
  end.

Ltac hextract_main tt :=
  check_goal_himpl tt;
  hextract_setup tt;
  (repeat (hextract_step tt));
  hextract_cleanup tt.

Ltac hextract_core :=
  hextract_main tt.

Ltac hextract_if_needed tt :=
  match goal with |- ?H ==> _ => match H with
  | context [ heap_is_pack _ ] => hextract_core
  | context [ [ _ ] ] => hextract_core
  end end.

Tactic Notation "hextract" := 
  hextract_core; intros.
Tactic Notation "hextract" "as" := 
  hextract_core.
Tactic Notation "hextract" "as" simple_intropattern(I1) := 
  hextract as; intros I1.
Tactic Notation "hextract" "as" simple_intropattern(I1) simple_intropattern(I2) := 
  hextract as; intros I1 I2.
Tactic Notation "hextract" "as" simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) := 
  hextract as; intros I1 I2 I3.
Tactic Notation "hextract" "as" simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) := 
  hextract as; intros I1 I2 I3 I4. 
Tactic Notation "hextract" "as" simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5) := 
  hextract as; intros I1 I2 I3 I4 I5. 
Tactic Notation "hextract" "as" simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) := 
  hextract as; intros I1 I2 I3 I4 I5 I6. 
Tactic Notation "hextract" "as" simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) := 
  hextract as; intros I1 I2 I3 I4 I5 I6 I7. 


Inductive Hsimpl_hint : list Boxer -> Type :=
  | hsimpl_hint : forall (L:list Boxer), Hsimpl_hint L.

Ltac hsimpl_hint_put L := 
  lets: (hsimpl_hint L).

Ltac hsimpl_hint_next cont :=
  match goal with H: Hsimpl_hint ((boxer ?x)::?L) |- _ =>
    clear H; hsimpl_hint_put L; cont x end.

Ltac hsimpl_hint_remove :=
  match goal with H: Hsimpl_hint _ |- _ => clear H end.

Lemma demo_hsimpl : exists n, n = 3.
Proof.
  hsimpl_hint_put (>>> 3 true).
  hsimpl_hint_next ltac:(fun x => exists x).
  hsimpl_hint_remove.
  auto.
Qed.


Lemma hsimpl_start : forall H1 H2,
  H1 \* [] ==> [] \* (H2 \* []) -> H1 ==> H2.
Proof. intros. rew_heap in *. auto. Qed.

Lemma hsimpl_keep : forall H1 H2 H3 H4,
  H1 ==> (H2 \* H3) \* H4 -> H1 ==> H2 \* (H3 \* H4).
Proof. intros. rew_heap in *. auto. Qed.

Lemma hsimpl_extract_prop : forall H1 H2 H3 (P:Prop),
  H1 ==> H2 \* H3 -> P -> H1 ==> H2 \* ([P] \* H3).
Proof.
  introv W HP PH1. destruct (W _ PH1) as (h1&h2&?&?&?&?).
  exists h1 h2. splits~. exists heap_empty h2. splits~.
Qed.

Lemma hsimpl_extract_id : forall A (x X : A) H1 H2 H3,
  H1 ==> H2 \* H3 -> x = X -> H1 ==> H2 \* (x ~> Id X \* H3).
Proof. intros. unfold Id. apply~ hsimpl_extract_prop. Qed.

Lemma hsimpl_extract_exists : forall A (x:A) H1 H2 H3 (J:A->hprop),
  H1 ==> H2 \* J x \* H3 -> H1 ==> H2 \* (heap_is_pack J \* H3).
Proof.
  introv W. intros h1 PH1. destruct (W _ PH1) as (h2&h4&?&(hx&h3&?&?&?&?)&?&?).
  exists h2 (heap_union hx h3). subst h1 h4. splits~.
  exists hx h3. splits~. exists~ x.
Qed.

Lemma hsimpl_cancel_1 : forall H HA HR HT,
  HT ==> HA \* HR -> H \* HT ==> HA \* (H \* HR).
Proof. intros. rewrite star_comm_assoc. apply~ star_cancel. Qed.

Lemma hsimpl_cancel_2 : forall H HA HR H1 HT,
  H1 \* HT ==> HA \* HR -> H1 \* H \* HT ==> HA \* (H \* HR).
Proof. intros. rewrite (star_comm_assoc H1). apply~ hsimpl_cancel_1. Qed.

Lemma hsimpl_cancel_3 : forall H HA HR H1 H2 HT,
  H1 \* H2 \* HT ==> HA \* HR -> H1 \* H2 \* H \* HT ==> HA \* (H \* HR).
Proof. intros. rewrite (star_comm_assoc H2). apply~ hsimpl_cancel_2. Qed.

Lemma hsimpl_cancel_4 : forall H HA HR H1 H2 H3 HT,
  H1 \* H2 \* H3 \* HT ==> HA \* HR -> H1 \* H2 \* H3 \* H \* HT ==> HA \* (H \* HR).
(*Proof. intros. rewrite (star_comm_assoc H3). apply~ hsimpl_cancel_3. Qed.*)
Admitted. (* skip proof for faster compilation *)

Lemma hsimpl_cancel_5 : forall H HA HR H1 H2 H3 H4 HT,
  H1 \* H2 \* H3 \* H4 \* HT ==> HA \* HR -> H1 \* H2 \* H3 \* H4 \* H \* HT ==> HA \* (H \* HR).
(*Proof. intros. rewrite (star_comm_assoc H4). apply~ hsimpl_cancel_4. Qed.*)
Admitted.

Lemma hsimpl_cancel_6 : forall H HA HR H1 H2 H3 H4 H5 HT,
  H1 \* H2 \* H3 \* H4 \* H5 \* HT ==> HA \* HR -> H1 \* H2 \* H3 \* H4 \* H5 \* H \* HT ==> HA \* (H \* HR).
(*Proof. intros. rewrite (star_comm_assoc H5). apply~ hsimpl_cancel_5. Qed.*)
Admitted.

Lemma hsimpl_cancel_eq_1 : forall H H' HA HR HT,
  H = H' -> HT ==> HA \* HR -> H \* HT ==> HA \* (H' \* HR).
Proof. intros. subst. apply~ hsimpl_cancel_1. Qed.

Lemma hsimpl_cancel_eq_2 : forall H H' HA HR H1 HT,
  H = H' -> H1 \* HT ==> HA \* HR -> H1 \* H \* HT ==> HA \* (H' \* HR).
Proof. intros. subst. apply~ hsimpl_cancel_2. Qed.

Lemma hsimpl_cancel_eq_3 : forall H H' HA HR H1 H2 HT,
  H = H' -> H1 \* H2 \* HT ==> HA \* HR -> H1 \* H2 \* H \* HT ==> HA \* (H' \* HR).
Proof. intros. subst. apply~ hsimpl_cancel_3. Qed.

Lemma hsimpl_cancel_eq_4 : forall H H' HA HR H1 H2 H3 HT,
  H = H' -> H1 \* H2 \* H3 \* HT ==> HA \* HR -> H1 \* H2 \* H3 \* H \* HT ==> HA \* (H' \* HR).
Proof. intros. subst. apply~ hsimpl_cancel_4. Qed.

Lemma hsimpl_cancel_eq_5 : forall H H' HA HR H1 H2 H3 H4 HT,
  H = H' -> H1 \* H2 \* H3 \* H4 \* HT ==> HA \* HR -> H1 \* H2 \* H3 \* H4 \* H \* HT ==> HA \* (H' \* HR).
Proof. intros. subst. apply~ hsimpl_cancel_5. Qed.

Lemma hsimpl_cancel_eq_6 : forall H H' HA HR H1 H2 H3 H4 H5 HT,
  H = H' -> H1 \* H2 \* H3 \* H4 \* H5 \* HT ==> HA \* HR -> H1 \* H2 \* H3 \* H4 \* H5 \* H \* HT ==> HA \* (H' \* HR).
Proof. intros. subst. apply~ hsimpl_cancel_6. Qed.

Ltac hsimpl_setup tt :=
  apply hsimpl_start;
  protect_evars tt; 
  autorewrite with hsimpl_assoc.

Ltac hsimpl_try_same tt :=
  first 
  [ apply hsimpl_cancel_1
  | apply hsimpl_cancel_2
  | apply hsimpl_cancel_3
  | apply hsimpl_cancel_4
  | apply hsimpl_cancel_5
  | apply hsimpl_cancel_6 ].

Ltac hsimpl_find_same H HL :=
  match HL with
  | H \* _ => apply hsimpl_cancel_1
  | _ \* H \* _ => apply hsimpl_cancel_2
  | _ \* _ \* H \* _ => apply hsimpl_cancel_3
  | _ \* _ \* _ \* H \* _ => apply hsimpl_cancel_4
  | _ \* _ \* _ \* _ \* H \* _ => apply hsimpl_cancel_5
  | _ \* _ \* _ \* _ \* _ \* H \* _ => apply hsimpl_cancel_6
  end.

Ltac hsimpl_find_data H HL :=
  match H with hdata _ ?l =>
  match HL with
  | hdata _ l \* _ => apply hsimpl_cancel_eq_1
  | _ \* hdata _ l \* _ => apply hsimpl_cancel_eq_2
  | _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_eq_3
  | _ \* _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_eq_4
  | _ \* _ \* _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_eq_5
  | _ \* _ \* _ \* _ \* _ \* hdata _ l \* _ => apply hsimpl_cancel_eq_6
  end end; [ fequal; fequal | ].

Ltac hsimpl_extract_exists_with_hints tt :=
  match goal with |- ?HL ==> ?HA \* (heap_is_pack ?J \* ?HR) =>
    hsimpl_hint_next ltac:(fun x =>
      match x with
      | __ => eapply hsimpl_extract_exists
      | _ => apply (@hsimpl_extract_exists _ x)
      end)
  end.

Ltac hsimpl_extract_exists_step tt :=
  first [ hsimpl_extract_exists_with_hints tt
        | eapply hsimpl_extract_exists ];
   autorewrite with hsimpl_assoc.

Ltac hsimpl_step tt :=
  match goal with |- ?HL ==> ?HA \* (?H \* ?HR) =>
    first  (* hsimpl_find_same H HL |*)
          [ hsimpl_try_same tt 
          | hsimpl_find_data H HL;
            [ first [ eassumption | symmetry; eassumption | idtac ]
            | ]
          | apply hsimpl_extract_prop
          | apply hsimpl_extract_id
          | hsimpl_extract_exists_step tt
          | apply hsimpl_keep ]
  end.

Ltac hsimpl_cleanup tt :=
  autorewrite with hsimpl_neutral;
  unprotect_evars tt;
  try apply pred_le_refl;
  try hsimpl_hint_remove.

Ltac hsimpl_main tt :=
  check_goal_himpl tt;
  hsimpl_setup tt;
  (repeat (hsimpl_step tt));
  hsimpl_cleanup tt.

Tactic Notation "hsimpl" := hsimpl_main tt.
Tactic Notation "hsimpl" "~" := hsimpl; auto_tilde.
Tactic Notation "hsimpl" "*" := hsimpl; auto_star.
Tactic Notation "hsimpl" constr(L) :=
  match type of L with 
  | list Boxer => hsimpl_hint_put L
  | _ => hsimpl_hint_put (boxer L :: nil)
  end; hsimpl.
Tactic Notation "hsimpl" constr(X1) constr(X2) :=
  hsimpl (>>> X1 X2).
Tactic Notation "hsimpl" constr(X1) constr(X2) constr(X3) :=
  hsimpl (>>> X1 X2 X3).

Tactic Notation "hsimpl" "~" constr(L) :=
  hsimpl L; auto~.
Tactic Notation "hsimpl" "~" constr(X1) constr(X2) :=
  hsimpl X1 X2; auto~.
Tactic Notation "hsimpl" "~" constr(X1) constr(X2) constr(X3) :=
  hsimpl X1 X2 X3; auto~.



(********************************************************************)
(* ** Extraction tactic for local goals *)

Ltac xlocal_core tt :=
  first [ assumption | apply local_is_local ].
  (* match goal with |- is_local _ =>  end. *)

Tactic Notation "xlocal" :=
  xlocal_core tt.

Lemma hclean_start : forall B (F:~~B) H Q,
  is_local F -> F ([] \* (H \* [])) Q -> F H Q.
Proof. intros. rew_heap in *. auto. Qed.

Lemma hclean_step : forall B (F:~~B) H1 H2 H3 Q,
  F ((H1 \* H2) \* H3) Q -> F (H1 \* (H2 \* H3)) Q.
Proof. intros. rew_heap in *. auto. Qed.

Lemma hclean_prop : forall B (F:~~B) H1 H2 (P:Prop) Q,
  is_local F -> (P -> F (H1 \* H2) Q) -> F (H1 \* [P] \* H2) Q.
Proof.
  intros. rewrite star_comm_assoc. apply~ local_intro_prop'. 
Qed. 

Lemma hclean_id : forall A (x X : A) B (F:~~B) H1 H2 Q,
  is_local F -> (x = X -> F (H1 \* H2) Q) -> F (H1 \* x ~> Id X \* H2) Q.
Proof. intros. unfold Id. apply~ hclean_prop. Qed.

Lemma hclean_exists : forall B (F:~~B) H1 H2 A (J:A->hprop) Q,
  is_local F -> 
  (forall x, F (H1 \* (J x) \* H2) Q) ->
   F (H1 \* (heap_is_pack J \* H2)) Q.
Proof. 
  intros. rewrite star_comm_assoc. apply~ local_intro_exists.
  intros. rewrite~ star_comm_assoc.
Qed. 

Ltac hclean_onH cont :=
  match goal with
  | |- _ ?H ?Q => cont H
  | |- _ _ ?H ?Q => cont H
  | |- _ _ _ ?H ?Q => cont H
  | |- _ _ _ _ ?H ?Q => cont H
  | |- _ _ _ _ _ ?H ?Q => cont H
  | |- _ _ _ _ _ _ ?H ?Q => cont H
  end.

Ltac hclean_onQ cont :=
  match goal with
  | |- _ ?H ?Q => cont Q
  | |- _ _ ?H ?Q => cont Q
  | |- _ _ _ ?H ?Q => cont Q
  | |- _ _ _ _ ?H ?Q => cont Q
  | |- _ _ _ _ _ ?H ?Q => cont Q
  | |- _ _ _ _ _ _ ?H ?Q => cont Q
  end.

Ltac hclean_protect tt :=
  let Q' := fresh "TEMP" in
  hclean_onQ ltac:(fun Q => set (Q' := Q : ltac_tag_subst _));
  do 5 try (hclean_onH ltac:(fun H => protect_evars_in H); instantiate).

Ltac hclean_setup tt :=
  hclean_protect tt;
  apply hclean_start; [ try xlocal | ];
  autorewrite with hsimpl_assoc.

Ltac hclean_relinearize tt :=
  let go Hpre := match Hpre with ?H \* (_ \* _) =>
    let T := fresh "TEMP" in 
    sets T: H; 
    autorewrite with hsimpl_assoc; 
    subst T
    end in
  hclean_onH ltac:(go).
 
Ltac hclean_step tt :=
  let go H :=
    match H with ?HA \* ?HX \* ?HR => match HX with
    | [?P] => apply hclean_prop; [ try xlocal | intro ]
    | ?x ~> Id ?X => apply hclean_id; [ try xlocal | intro ]
    | heap_is_pack ?J => apply hclean_exists; [ try xlocal | intro; hclean_relinearize tt ]
    | _ => apply hclean_step
    end end in
  hclean_onH ltac:(go).

Ltac hclean_cleanup tt :=
  autorewrite with hsimpl_neutral;_evars tt.

Ltac hclean_main tt :=
  hclean_setup tt;
  pose ltac_mark; 
  (repeat (hclean_step tt));
  hclean_cleanup tt;
  gen_until_mark.

Tactic Notation "hclean" := hclean_main tt.
Tactic Notation "hclean" "~" := hclean; auto_tilde.
Tactic Notation "hclean" "*" := hclean; auto_star.



(* asserts M: (forall P Q Q' : Prop, (P Q <-> Q') -> (P /\ Q <-> P /\ Q')). applys (rm M).*)
test (index L j) as Ij; auto*. rewrite (prop_eq_True_back Ij); rew_logic.
rewrite~ (array_update_read_neq (t:=Idx)).
test (index n (Idx\(j))) as Iidx. rewrite (prop_eq_True_back Iidx); rew_logic.
 asserts: (n <> Idx\(j)). rewrite int_index_def in Iidx. math.
 asserts: (index Back (Idx\(j))). apply* index_array_length_le. myunfold. math.
  iff M [Inj Eq].
     split. rewrite int_index_def in Iidx|-*. math.
            rew_array~.
  rew_array in Eq; auto.

test (n = Idx\(j)) as EQn. iff [Inj EQ]; false.
  rewrite <- EQn in EQ, Inj. 
  rewrite (array_update_read_eq) in EQ. false.  
  apply* index_array_length_le. myunfold. math.
rewrite (prop_eq_False_back Iidx); rew_logic. iff ? [Inj EQ]; tryfalse.
apply Iidx. rewrite int_index_def in Inj|-*. math.



(*

Lemma Id_focus : forall A (x n : A),
  x ~> Id n ==> [x = n].
Proof. intros. unfold Id. hdata_simpl. hextract. hsimpl~. Qed.

Lemma Id_unfocus : forall A (x : A),
  [] ==> x ~> Id x.
Proof. intros. unfold Id. hdata_simpl. hextract. hsimpl~. Qed.

Implicit Arguments Id_focus [A].
Implicit Arguments Id_unfocus [A].
*)




Lemma cases_or_l : forall (P Q:Prop),
  P \/ (~ P /\ Q) \/ (~ P /\ ~ Q).
Proof. intros. tautoB P Q. Qed.
(**

Ltac my_cases :=
  apply_to_If ltac:(fun B =>
    match B with ?P \/ ?Q =>
     destruct (cases_or_l P Q) as [So|[[So Vi]|[So Vi]]] end).

*)
Lemma mininf_len_lt_not : forall d A (f:A->int) (P:A->Prop),
  ~ (len_lt (mininf f P) d) ->
  value_nonneg f P ->
  exists x, P x /\ f x <= d.
Proof.
  unfold len_lt. introv H NE. sets_eq l:(mininf f P).  (* todo: case_eq*)
  destruct l.
    unfold mininf in EQl. case_if; tryfalse. inverts EQl.
     destruct e as [x Px]. 
skip. 
    false~ H.
Qed.


(*--bin
Lemma inv_step_end : forall V x H B L,
  (forall y w, Mem (y,w) L = has_edge G x y w) ->  (* todo: use def for this *)
  V\(x) = false ->
  inv V B H (new_enters x L V) ->
  inv (V\(x:=true)) B H (enters (V\(x:=true))).
Proof.
  introv EL Vx [Dok Hcorr Hcomp]. constructors; unfolds.
  intros. tests (x = z); rew_array~.
    case_If as _ [_ ?]. skip. (*best*)
    specializes Dok z. case_If as I.
      auto.
      rewrite~ enters_step in Dok.
  introv Vz Nze Hzd. tests (x = z).
   rewrite~ @array_update_read_eq in Vz. false. (* todo: fix*)
   rew_array~ in Vz. forwards~ (p&M&?): Hcorr Hzd. 
    exists p. split~. rewrite~ enters_step in M.
  introv En. tests (x = z).
    false. lets ((_&E)&_): En. rewrite~ @array_update_read_eq in E. false. (* todo: fix*)
    apply Hcomp. rewrite~ enters_step.
Qed.
*)

(* bin
Lemma inv_extract_size : forall V B Q reach,
  [inv V B Q reach] ==> [size_ok V] \* [size_ok B] \* [inv V B Q reach].
Proof. intros. hextract as I. lets [_ ? ?]: I. hsimpl~. Qed.
*)



(*
Ltac xgen_abstract H E :=
  let Jx := eval pattern E in H in
  match Jx with ?J _ => constr:(heap_is_pack J) end.

Ltac xgen_nosimpl E :=
  match goal with |- ?H ==> _ =>
    let H' := xgen_abstract H E in 
    apply (@pred_le_trans _ H') end.
*)

(*bin:    xapp_manual. xapply (KR I); clear KR.*)

Axiom boolneg : forall b, !b -> b = false.
Hint Resolve boolneg.



Axiom bool_neq_true_eq_false : forall b,
  b <> true -> b = false.
Hint Resolve bool_neq_true_eq_false.

Hint Resolve istrue_True.

(*
Lemma size_ok_elim : forall `{Inhab A} (T:array A) x,
  size_ok T -> x \in nodes G -> index T x.
Proof. unfolds~ size_ok. Qed.
Hint Extern 1 (index _ _) => apply size_ok_elim.
*)


Lemma graph_adj_index : forall A B (T:array A) (G:graph B) n x,
  nodes_index G n -> length T = n -> x \in nodes G -> index T x.
Proof. introv Nod Len Nx. subst. rewrite array_index_def. rewrite~ <- Nod. Qed.

(*
Definition size_ok A (T:array A) :=
  forall x, x \in nodes G -> index T x.  
*)


Axiom bool_test' : forall b,
  b = true \/ b = false.





Lemma step_all_imper_spec : 
  Spec step_all_imper (l:loc) |R>> forall L, 
    R (l ~> MList Counter L) (# l ~> MList Counter (LibList.map (fun i => i+1) L)).
Proof.
  xcf. intros. xfun (fun g => Spec g f |R>> forall (Q':int->hprop) H (Q:unit->hprop),
    (App f tt;) H Q' -> (forall x, Q' x ==> Q tt) -> R H Q).
    intros M W. xlet. apply M. xapp. hsimpl. applys pred_le_trans (W _x3). hsimpl.
    renames _f0 to g, S_f0 to Sg.
  lets K: (>> (spec_elim_2 (@miter_spec func int)) [] []). xapply K; try hsimpl.
  introv In Ic. generalize l. clears l. induction L; intros. apply In.
  rewrite map_cons. apply Ic. exists []. split.
  intros f. xapp. apply Counter_apply. intros r. hextract. apply hsimpl_to_qunit. reflexivity.
   hsimpl. hsimpl. intros m'. apply IHL.
Qed.




(********************************************************************)
(* ** Imperative functional list iterator --OLD

Lemma miter_spec : forall a A,
  Spec miter (f:func) (m:loc) | R>>
    forall (T:A->a->hprop) H H' (L L':list A),
    (forall (I:loc -> list A -> list A -> hprop -> hprop -> Prop), 
       (forall m H, I m nil nil H H) ->
       (forall m H H' X X' L L',
          (exists H'', (forall x, (App f x;) (H \* x ~> T X) (# H'' \* x ~> T X'))
                   /\ (forall m', I m' L L' H'' H')) ->
          I m (X::L) (X'::L') H H') ->
       I m L L' H H') ->
    R (H \* m ~> MList T L) (# H' \* m ~> MList T L'). 
Proof.
  intros. xcf. introv M. xapp. xwhile.
  sets I: (fun m L L' H H' => R (H \* m ~> MList T L \* h ~> Ref Id m) (# H' \* m ~> MList T L')).
  specializes M I. unfold I in M at 4.
  apply M; clears H.
  (* nil *)
  intros. unfolds. apply HR. xchange (@MList_nil m) as M. subst_hyp M.
  xlet. xapps. xapps. xextracts. xif. xret_gc. hchanges (MList_unnil).
  (* cons *)
  introv (H''&B1&B2). unfolds. apply HR. xchange (@MList_cons m) as x m'.
   xchange (@Mlist_not_null m). xextract as N.
  xlet. xapps. xapps. xextracts. xif. 
  xseq. xapps. xapp_spec (@_get_hd_spec a loc). intro_subst.
  xseq. xapplys B1. apply hsimpl_to_qunit. reflexivity.
   (* xseq (# H'' \* m' ~> MList T L0 \* x ~> T X' \* h ~> Ref Id m \* m ~> Mlist Id Id x m').*)
  xapps. xapps. xapps. unfold I in B2. xapply B2. hsimpl. hsimpl.
  hchange (@MList_uncons m). hsimpl.
Qed.

Hint Extern 1 (RegisterSpec miter) => Provide miter_spec.
 *)




Lemma while_loop_cf_to_inv : 
   forall (A:Type) (I:A->hprop) (lt:binary A) (W:wf lt),
   forall (F1:~~bool) (F2:~~unit) H (Q:unit->hprop),
   is_local F1 -> is_local F2 ->
   (exists X0, H ==> (I X0)) ->
   (forall X, local (fun H Q => exists Q',
        F1 H Q' 
     /\ F2 (Q' true) (# Hexists Y, (I Y) \* [lt Y X])
     /\ Q' false ==> Q tt) (I X) Q) ->
  (While F1 Do F2 _Done) H Q.
Proof.
  introv W LF1 LF2 (X0&I0) M. apply local_erase.
  introv LR HR. applys* local_weaken (rm I0). gen X0.
  intros X. induction_wf IH: W X. 
  applys HR. intros h IXh.
  destruct~ (M X h) as (H1&H2&Q1&H3&M1&(Q'&M2&M3&M4)&M5).
  exists (H1 \* H2) [] (Q \*+ H3) H3. splits*.
  exists___. splits*.
  exists (Q' \*+ H2). splits~. xapplys M2.
  intros x. xpost; [ | apply M5 ]. applys local_frame H2. xlocal.
 xframe H2.
; [| xsimpl]. skip. apply pred_le_
 eapply local_wgframe. xlocal.
  xframe H2; [ | apply M5].
  intros m. destruct m. hsimpl.
xif.
    xseq (#Hexists Y, I Y \* [lt Y X] \* H2). xapplys* M3.
     intros Y LYX. skip.
    xret. destruct x; auto_false. hchange M4. hchange M5; hsimpl. 



    intros Y LYX. eapply local_wgframe. eauto. eauto.
     hsimpl. hchange M5.
 eapply xchange_lemma
xweaken_post (Q \*+ H3). xgc. xapply_local* IH. hsimpl. hchange 
    xret. destruct x; auto_false. hchange M4. hsimpl.
  intros m. destruct m. hchange M5; hsimpl.
Qed.
 
  intros x. xif. xseq*. xextract as Y L. eauto.
skip. 
(* xapply_local IH. eauto. hsimpl. skip. *)
  xret. destruct x; auto_false.

  cuts K: (forall X, exists H, R (I X) Q'(Q \* H)).
 exists (fun x:bool => if x then Q else Q1). splits~. intros x.
  xif. xseq*. xextract as Y L. eauto.
  xapply_local* IH; hsimpl.
  xret. destruct x; auto_false. hchange M4.
Qed.


(*
Proof.
  introv W (X0&I0) M. apply local_erase.
  introv LR HR. applys* local_weaken (rm I0). gen X0. 
  intros X. induction_wf IH: W X. 
  rewrite LR. introv Hh.
  lets (H1&H2&Q1&H'&?&(Q'&?&?&?)&?): (>> (rm M) X Hh).
  exists (H1 \* H2) [] (Q1 \*+ H2) H'. splits~.
  rew_heap~.
  applys HR. xextract. xlet (Q' \*+ H2). skip. (* todo: F1 local *)
  xif. xseq  (#Hexists Y, I Y \* [lt Y X] \* H2). skip. 
  intros Y L. xapply_local* IH; hsimpl.
  xret. destruct x; auto_false. hsimpl. 
Qed.
*)
Admitted.

Ltac xwhile_inv_core W I :=
  match type of W with
  | wf _ => eapply (@while_loop_cf_to_inv _ I _ W)
  | _ -> nat => eapply (@while_loop_cf_to_inv _ I (measure W)); [ try prove_wf | | ]
  | _ => eapply (@while_loop_cf_to_inv _ I W); [ try prove_wf | | ]
  end.

Tactic Notation "xwhile_inv" constr(W) constr(I) :=
  xwhile_pre ltac:(fun _ => xwhile_inv_core W I).

Tactic Notation "xwhile_inv_body" :=
  apply local_erase; esplit; splits (3%nat). 




#for debugging:
#changes: $(MYOCAMLDEP)
#	$(MYOCAMLDEP) $(INCLUDES) imper/Counter.ml > changes

